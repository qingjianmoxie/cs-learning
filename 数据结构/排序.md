# 排序

前 提
void x_sort ( ElementType A[], int N )
+ 大多数情况下，为简单起见，讨论从小大的整数排序
+ N是正整数
+ 只讨论基于比较的排序（ > = < 有定义）
+ 只讨论内部排序
+ 稳定性：任意两个相等的数据, 排序前后的相对位置不发生改变
+ 没有一种排序是任何情况下都表现最好

## 冒泡排序

最好情况：顺序 T = O(N)
最坏情况：逆序 T = O(N2)

如果所有待排序的元素是存放在单向链表中的, 使用冒泡排序有优势.

冒泡排序是稳定的.

C语言实现:
    [bubble_sort.c](../code/bubble_sort.c)

## 插入排序

最好情况：顺序 T = O(N)
最坏情况：逆序 T = O(N2)

插入排序是稳定的.

C语言实现:
    [insert_sort.c](../code/insert_sort.c)

## 时间复杂度下界

先思考一下给定初始序列{34, 8, 64, 51, 32, 21}，冒泡排序和插入排序分别需要多少次元素交换才能完成？

逆序对的定义:
对于下标i<j, 如果A[i]>A[j]，则称(i,j)是一对逆序对(inversion)

问题：序列{34, 8, 64, 51, 32, 21}中有多少逆序对？
答案: 有9个逆序对
+ 交换2个相邻元素正好消去1个逆序对！
+ 插入排序： T(N, I) = O(N+I)
    I表示序列中逆序对的个数.
所以如果序列基本有序，则插入排序简单且高效.

+ 定理：任意N个不同元素组成的序列平均具有`N(N-1)/4`个逆序对。
+ 定理：任何仅以交换**相邻**两元素来排序的算法，其平均时间复杂度为`Ω(N2)`。

这意味着：要提高算法效率，我们必须:
+ 每次消去不止1个逆序对！
+ 每次交换相隔较远的2个元素！

## 希尔排序

定义增量序列 DM > DM-1 > … > D1 = 1
+ 对每个Dk 进行“Dk间隔”排序( k = M, M-1, … 1 )
+ 注意: "Dk-间隔"有序的序列，在执行"Dk-1间隔"排序后，仍然是"Dk间隔"有序的

原始希尔排序 DM = N / 2 , Dk = Dk+1 / 2

C语言实现:
    [shell_sort.c](../code/shell_sort.c)

## 选择排序

C语言实现:
    [selection_sort.c](../code/selection_sort.c)

## 堆排序

堆排序实际是对选择排序的一个改进.

C语言实现:
    [heap_sort.c](../code/heap_sort.c)

+ 定理：堆排序处理N个不同元素的随机排列的平均比较次数是`2NlogN - O(Nlog logN)`。
+ 虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。

## 归并排序

+ 递归算法

C语言实现:
    [heap_sort.c](../code/merge_sort_1.c)

+ 非递归算法

C语言实现:
    [heap_sort.c](../code/merge_sort_2.c)

归并排序是稳定的.

由于归并排序需要额外的空间, 所以在内部排序中基本不用, 主要用于外部排序.

## 快速排序

C语言实现:
    [heap_sort.c](../code/quick_sort.c)