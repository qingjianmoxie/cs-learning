# 排序

前 提
void x_sort ( ElementType A[], int N )
+ 大多数情况下，为简单起见，讨论从小大的整数排序
+ N是正整数
+ 只讨论基于比较的排序（ > = < 有定义）
+ 只讨论内部排序
+ 稳定性：任意两个相等的数据, 排序前后的相对位置不发生改变
+ 没有一种排序是任何情况下都表现最好

## 冒泡排序

最好情况：顺序 T = O(N)
最坏情况：逆序 T = O(N2)

如果所有待排序的元素是存放在单向链表中的, 使用冒泡排序有优势.

冒泡排序是稳定的.

C语言实现:
    [bubble_sort.c](../code/bubble_sort.c)

## 插入排序

最好情况：顺序 T = O(N)
最坏情况：逆序 T = O(N2)

插入排序是稳定的.

C语言实现:
    [insert_sort.c](../code/insert_sort.c)

## 时间复杂度下界

先思考一下给定初始序列{34, 8, 64, 51, 32, 21}，冒泡排序和插入排序分别需要多少次元素交换才能完成？

逆序对的定义:
对于下标i<j, 如果A[i]>A[j]，则称(i,j)是一对逆序对(inversion)

问题：序列{34, 8, 64, 51, 32, 21}中有多少逆序对？
答案: 有9个逆序对
+ 交换2个相邻元素正好消去1个逆序对！
+ 插入排序： T(N, I) = O(N+I)
    I表示序列中逆序对的个数.
所以如果序列基本有序，则插入排序简单且高效.

+ 定理：任意N个不同元素组成的序列平均具有`N(N-1)/4`个逆序对。
+ 定理：任何仅以交换**相邻**两元素来排序的算法，其平均时间复杂度为`Ω(N2)`。

这意味着：要提高算法效率，我们必须:
+ 每次消去不止1个逆序对！
+ 每次交换相隔较远的2个元素！

## 选择排序

C语言实现:
    [selection_sort.c](../code/selection_sort.c)