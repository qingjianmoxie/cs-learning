# 哈夫曼树(Huffman Tree)与哈夫曼编码

## 哈夫曼树的定义

带权路径长度(WPL)： 设二叉树有n个叶子结点，每个叶子结点带有权值$w_k$，从根结点到每个叶子结点的长度为$l_k$，则每个叶子结点的带权路径长度之和就是: $WPL= \sum_{k=1}^n w_k l_k$ 
(权值可以理解为查找的频率)
最优二叉树或哈夫曼树: WPL最小的二叉树

## 哈夫曼树的构造
```c
typedef struct TreeNode *HuffmanTree;
struct TreeNode
{
    int Weight;
    HuffmanTree Left, Right;
};
HuffmanTree Huffman(MinHeap H)
{ /* 假设H->Size个权值已经存在H->Elements[]->Weight里 */
    int i;
    HuffmanTree T;
    BuildMinHeap(H); /*将H->Elements[]按权值调整为最小堆*/
    for (i = 1; i < H->Size; i++)
    {                                        /*做H->Size-1次合并*/
        T = malloc(sizeof(struct TreeNode)); /*建立新结点*/
        T->Left = DeleteMin(H);
        /*从最小堆中删除一个结点， 作为新T的左子结点*/
        T->Right = DeleteMin(H);
        /*从最小堆中删除一个结点， 作为新T的右子结点*/
        T->Weight = T->Left->Weight + T->Right->Weight;
        /*计算新权值*/
        Insert(H, T); /*将新T插入最小堆*/
    }
    T = DeleteMin(H);
    return T;
}
```
整体复杂度为O(NlogN)

## 哈夫曼树的特点:
+ 没有度为1的结点；
+ 哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树；
+ n个叶子结点的哈夫曼树共有2n-1个结点；
+ 对同一组权值{w1 ,w2 , …… , wn}， 可能存在不同构的两棵哈夫曼树呢