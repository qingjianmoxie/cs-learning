# 单列模式

- [单列模式](#单列模式)
  - [什么是线程安全？](#什么是线程安全)
  - [如何保证线程安全？](#如何保证线程安全)
  - [什么是单例模式？](#什么是单例模式)
    - [单例模式分类](#单例模式分类)
    - [单例类特点](#单例类特点)
  - [01 普通懒汉式单例 （ 线程不安全 ）](#01-普通懒汉式单例--线程不安全-)
      - [普通懒汉式单例运行结果：](#普通懒汉式单例运行结果)
  - [02 加锁的懒汉式单例 (线程安全)](#02-加锁的懒汉式单例-线程安全)
      - [加锁的懒汉式单例的运行结果：](#加锁的懒汉式单例的运行结果)
  - [03 内部静态变量的懒汉单例（C++11 线程安全）](#03-内部静态变量的懒汉单例c11-线程安全)
      - [内部静态变量的懒汉单例的运行结果：](#内部静态变量的懒汉单例的运行结果)
  - [04 饿汉式单例 （本身就线程安全）](#04-饿汉式单例-本身就线程安全)
      - [饿汉式单例的运行结果：](#饿汉式单例的运行结果)
  - [特点与选择](#特点与选择)
  - [参考](#参考)

## 什么是线程安全？

在拥有**共享数据**的**多条线程并行执行**的程序中，线程安全的代码会通过**同步机制**保证**各个线程**都可以正常且正确的执行，不会出现数据污染等意外情况。

## 如何保证线程安全？

1.  给**共享的资源**加把**锁**，保证每个资源变量每时每刻至多被一个线程占用。
2.  让线程也拥有资源，不用去共享进程中的资源。如： 使用**threadlocal**可以为每个线程的维护一个**私有的**本地变量。

## 什么是单例模式？

单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的**唯一性**。

### 单例模式分类

单例模式可以分为**懒汉式**和**饿汉式**，两者之间的区别在于**创建实例的时间不同**：

* **懒汉式**：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。**（这种方式要考虑线程安全）**
* **饿汉式**：指系统一运行，就初始化创建实例，当需要时，直接调用即可。**（本身就线程安全，没有多线程的问题）**

### 单例类特点

* 构造函数和析构函数为**private**类型，目的**禁止**外部构造和析构
* 拷贝构造和赋值构造函数为**private**类型，目的是**禁止**外部拷贝和赋值，确保实例的唯一性
* 类里有个获取实例的**静态函数**，可以全局访问

## 01 普通懒汉式单例 （ 线程不安全 ）

[普通懒汉式单例](./src/普通懒汉式单列.cc)

#### 普通懒汉式单例运行结果：

    main() : 开始 ...
    main() : 创建线程:[0]
    main() : 创建线程:[1]
    Hi, 我是线程 ID:[0]
    Hi, 我是线程 ID:[1]
    main() : 创建线程:[2]
    构造函数
    我的实例内存地址是:0x7fa9d00008c0
    构造函数
    我的实例内存地址是:0x7fa9d80008c0
    main() : 创建线程:[3]
    Hi, 我是线程 ID:[2]
    我的实例内存地址是:0x7fa9d80008c0
    main() : 创建线程:[4]
    Hi, 我是线程 ID:[3]
    我的实例内存地址是:0x7fa9d80008c0
    析构函数
    Hi, 我是线程 ID:[4]
    main() : 结束!

从运行结果可知，单例构造函数创建了两个，内存地址分别为`0x7fa9d00008c0`和`0x7fa9d80008c0`，所以普通懒汉式单例只适合单进程不适合多线程，因为是线程不安全的。

## 02 加锁的懒汉式单例 (线程安全)

[加锁的懒汉式单例](./src/加锁的懒汉式单例.cc)

#### 加锁的懒汉式单例的运行结果：

    main() : 开始 ...
    main() : 创建线程:[0]
    main() : 创建线程:[1]
    Hi, 我是线程 ID:[0]
    构造函数
    我的实例内存地址是:0x7f80a40008c0
    main() : 创建线程:[2]
    Hi, 我是线程 ID:[1]
    我的实例内存地址是:0x7f80a40008c0
    main() : 创建线程:[3]
    Hi, 我是线程 ID:[2]
    我的实例内存地址是:0x7f80a40008c0
    main() : 创建线程:[4]
    Hi, 我是线程 ID:[3]
    我的实例内存地址是:0x7f80a40008c0
    析构函数
    main() : 结束!
    Hi, 我是线程 ID:[4]
    构造函数
    我的实例内存地址是:0x7f80a40008c0

从运行结果可知，只创建了一个实例，内存地址是`0x7f80a40008c0`，所以加了互斥锁的普通懒汉式是线程安全的
(实测不是, 随机出现内存地址不一致, 待解决)

## 03 内部静态变量的懒汉单例（C++11 线程安全）

```
///////////////////  内部静态变量的懒汉实现  //////////////////
class Single
{

public:
    // 获取单实例对象
    static Single &GetInstance();

	// 打印实例地址
    void Print();

private:
    // 禁止外部构造
    Single();

    // 禁止外部析构
    ~Single();

    // 禁止外部复制构造
    Single(const Single &signal);

    // 禁止外部赋值操作
    const Single &operator=(const Single &signal);
};

Single &Single::GetInstance()
{
    // 局部静态特性的方式实现单实例
    static Single signal;
    return signal;
}

void Single::Print()
{
	std::cout << "我的实例内存地址是:" << this << std::endl;
}

Single::Single()
{
    std::cout << "构造函数" << std::endl;
}

Single::~Single()
{
    std::cout << "析构函数" << std::endl;
}
///////////////////  内部静态变量的懒汉实现  //////////////////

```

#### 内部静态变量的懒汉单例的运行结果：

`-std=c++0x`编译是使用了C++11的特性，在C++11内部静态变量的方式里是线程安全的，只创建了一次实例，内存地址是`0x6016e8`，这个方式非常推荐，实现的代码最少！

```
[root@lincoding singleInstall]#g++  SingleInstance.cpp -o SingleInstance -lpthread -std=c++0x

```

![image](https://upload-images.jianshu.io/upload_images/22699730-357bd14b425c9613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* * *

## 04 饿汉式单例 （本身就线程安全）

```
////////////////////////// 饿汉实现 /////////////////////
class Singleton
{
public:
    // 获取单实例
    static Singleton* GetInstance();

    // 释放单实例，进程退出时调用
    static void deleteInstance();

    // 打印实例地址
    void Print();

private:
    // 将其构造和析构成为私有的, 禁止外部构造和析构
    Singleton();
    ~Singleton();

    // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值
    Singleton(const Singleton &signal);
    const Singleton &operator=(const Singleton &signal);

private:
    // 唯一单实例对象指针
    static Singleton *g_pSingleton;
};

// 代码一运行就初始化创建实例 ，本身就线程安全
Singleton* Singleton::g_pSingleton = new (std::nothrow) Singleton;

Singleton* Singleton::GetInstance()
{
    return g_pSingleton;
}

void Singleton::deleteInstance()
{
    if (g_pSingleton)
    {
        delete g_pSingleton;
        g_pSingleton = NULL;
    }
}

void Singleton::Print()
{
    std::cout << "我的实例内存地址是:" << this << std::endl;
}

Singleton::Singleton()
{
    std::cout << "构造函数" << std::endl;
}

Singleton::~Singleton()
{
    std::cout << "析构函数" << std::endl;
}
////////////////////////// 饿汉实现 /////////////////////

```

#### 饿汉式单例的运行结果：

从运行结果可知，饿汉式在程序一开始就构造函数初始化了，所以本身就线程安全的
![image](https://upload-images.jianshu.io/upload_images/22699730-52a9d97e2c2a1ff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 特点与选择

* 懒汉式是以时间换空间，适应于访问量较**小**时；推荐使用**内部静态变量的懒汉单例**，代码量少
* 饿汉式是以空间换时间，适应于访问量较**大**时，或者线程比较多的的情况

## 参考

- [C++ 线程安全的单例模式总结](https://www.cnblogs.com/xiaolincoding/p/11437231.html)
