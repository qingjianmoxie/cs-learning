# 数据库

- [数据库](#数据库)
  - [服务器中的数据库](#服务器中的数据库)
  - [切换数据库](#切换数据库)
  - [数据库键空间](#数据库键空间)
    - [添加新键](#添加新键)
    - [删除键](#删除键)
    - [更新键](#更新键)
    - [对键取值](#对键取值)
    - [其他键空间操作](#其他键空间操作)
    - [读写键空间时的维护操作](#读写键空间时的维护操作)
  - [设置键的生存时间或过期时间](#设置键的生存时间或过期时间)
    - [设置过期时间](#设置过期时间)
    - [保存过期时间](#保存过期时间)
    - [移除过期时间](#移除过期时间)
    - [计算并返回剩余生存时间](#计算并返回剩余生存时间)

本章将对Redis服务器的数据库实现进行详细介绍，说明服务器保存数据库的方法，客户端切换数据库的方法，数据库保存键值对的方法，以及针对数据库的添加、删除、查看、更新操作的实现方法等。除此之外，本章还会说明服务器保存键的过期时间的方法，以及服务器自动删除过期键的方法。最后，本章还会说明Redis 2.8新引入的数据库通知功能的实现方法。

## 服务器中的数据库

Redis服务器将所有数据库都保存在服务器状态server.h/redisServer结构的db数组中，db数组的每个项都是一个server.h/redisDb结构，每个redisDb结构代表一个数据库：

```c
struct redisServer {
    ...
    // 一个数组, 保存着服务器中的所有数据库
    redisDb *db;
    ...
    int dbnum;                      /* Total number of configured DBs */
    ...
};
```

在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库. dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库，如图9-1所示。

```
+-------------+
| redisServer |
+-------------+
|     ...     |
+-------------+       +-------+-------+-------+-----+--------+
|     db      | ----> | db[0] | db[1] | db[2] | ... | db[15] |
+-------------+       +-------+-------+-------+-----+--------+
|     ...     |
+-------------+
|    dbnum    |
|     16      |
+-------------+
|     ...     |
+-------------+
```

## 切换数据库

每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。
默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。
以下代码示例演示了客户端在0号数据库设置并读取键msg，之后切换到2号数据库并执行类似操作的过程：

    redis> SET msg "hello world"
    OK
    redis> GET msg
    "hello world"
    redis> SELECT 2
    OK
    redis[2]> GET msg
    (nil)
    redis[2]> SET msg "another world"
    OK
    redis[2]> GET msg
    "another world"

在服务器内部，客户端状态client结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针.
PS:
Another important Redis data structure is the one defining a client.
In the past it was called `redisClient`, now just `client`. 

```c
typedef struct client {
    ...
    // 记录客户端当前正在使用的数据库
    redisDb *db;            /* Pointer to currently SELECTed DB. */
    ...
} client;
```

client.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。通过修改client.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的实现原理。

**谨慎处理多数据库程序**

到目前为止，Redis仍然没有可以返回客户端目标数据库的命令。虽然redis-cli客户端会在输入符旁边提示当前所使用的目标数据库：

    redis> SELECT 1
    OK
    redis[1]> SELECT 2
    OK
    redis[2]>

但如果你在其他语言的客户端中执行Redis命令，并且该客户端没有像redis-cli那样一直显示目标数据库的号码，那么在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。

## 数据库键空间

Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：

```c
typedef struct redisDb {
    // 数据库键空间, 保存着数据库中的所有键值对
    dict *dict;                 /* The keyspace for this DB */
    ...
} redisDb;
```

键空间和用户所见的数据库是直接对应的：

❑键空间的键也就是数据库的键，每个键都是一个字符串对象。
❑键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。

举个例子，如果我们在空白的数据库中执行以下命令：

    redis> SET message "hello world"
    OK
    redis> RPUSH alphabet "a" "b" "c"
    (integer) 3
    redis> HSET book name "Redis in Action"
    (integer) 1
    redis> HSET book author "Josiah L. Carlson"
    (integer) 1
    redis> HSET book publisher "Manning"
    (integer) 1

那么在这些命令执行之后，数据库的键空间将会是图9-4所展示的样子：

❑alphabet是一个列表键，键的名字是一个包含字符串"alphabet"的字符串对象，键的值则是一个包含三个元素的列表对象。  
❑book是一个哈希表键，键的名字是一个包含字符串"book"的字符串对象，键的值则是一个包含三个键值对的哈希表对象。  
❑message是一个字符串键，键的名字是一个包含字符串"message"的字符串对象，键的值则是一个包含字符串"hello world"的字符串对象。

因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的，以下几个小节将分别介绍数据库的添加、删除、更新、取值等操作的实现原理。

### 添加新键

添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。
举个例子，如果键空间当前的状态如图9-4所示，那么在执行以下命令之后：

    redis> SET date "2013.12.1"
    OK

键空间将添加一个新的键值对，这个新键值对的键是一个包含字符串"date"的字符串对象，而键值对的值则是一个包含字符串"2013.12.1"的字符串对象，如图9-5所示。

### 删除键

删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。
举个例子，如果键空间当前的状态如图9-4所示，那么在执行以下命令之后：

    redis> DEL book
    (integer) 1

键book以及它的值将从键空间中被删除，如图9-6所示。

### 更新键

对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。
举个例子，如果键空间当前的状态如图9-4所示，那么在执行以下命令之后：

    redis> SET message "blah blah"
    OK

键message的值对象将从之前包含"hello world"字符串更新为包含"blah blah"字符串，如图9-7所示。

再举个例子，如果我们继续执行以下命令：

    redis> HSET book page 320
    (integer) 1

那么键空间中book键的值对象（一个哈希对象）将被更新，新的键值对page和320会被添加到值对象里面，如图9-8所示。

### 对键取值

对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。
举个例子，如果键空间当前的状态如图9-4所示，那么当执行以下命令时：

    redis> GET message
    "hello world"

GET命令将首先在键空间中查找键message，找到键之后接着取得该键所对应的字符串对象值，之后再返回值对象所包含的字符串"hello world"，取值过程如图9-9所示。

再举一个例子，当执行以下命令时：

    redis> LRANGE alphabet 0 -1
    1) "a"
    2) "b"
    3) "c"

LRANGE命令将首先在键空间中查找键alphabet，找到键之后接着取得该键所对应的列表对象值，之后再返回列表对象中包含的三个字符串对象的值，取值过程如图9-10所示。

### 其他键空间操作

除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的Redis命令，也是通过对键空间进行处理来完成的。
比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。
另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。

### 读写键空间时的维护操作

当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：

❑在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。
❑在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。
❑如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作，本章稍后对过期键的讨论会详细说明这一点。
❑如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过，第19章会详细说明这一点。
❑服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作，第10章、第11章和第15章都会说到这一点。
❑如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知，本章稍后讨论数据库通知功能的实现时会详细说明这一点。

## 设置键的生存时间或过期时间

通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：

    redis> SET key value
    OK
    redis> EXPIRE key 5
    (integer) 1
    redis> GET key // 5秒之内
    "value"
    redis> GET key // 5秒之后
    (nil)

**注意**
*SETEX命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定的命令（只能用于字符串键），所以本章不会对这个命令进行介绍，但SETEX命令设置过期时间的原理和本章介绍的EXPIRE命令设置过期时间的原理是完全一样的。*

与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。
过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键：

    redis> SET key value
    OK
    redis> EXPIREAT key 1599479200
    (integer) 1
    redis> TIME
    1) "1599479194"
    2) "731683"
    redis> GET key // 1599479200之前
    "value"
    redis> TIME
    1) "1599479210"
    2) "70171"
    redis> GET key // 1599479200之后
    (nil)

TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间：

    redis> SET key value
    OK
    redis> EXPIRE key 100
    (integer) 1
    redis> TTL key
    (integer) 96
    redis> SET another_key another_value
    OK
    redis> TIME
    1) "1599479540"
    2) "900121"
    redis> EXPIREAT another_key 1599480000
    (integer) 1
    redis> TTL another_key
    (integer) 420

在上一节我们讨论了数据库的底层实现，以及各种数据库操作的实现原理，但是，关于数据库如何保存键的生存时间和过期时间，以及服务器如何自动删除那些带有生存时间和过期时间的键这两个问题，我们还没有讨论。
本节将对服务器保存键的生存时间和过期时间的方法进行介绍，并在下一节介绍服务器自动删除过期键的方法。

### 设置过期时间

Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：
❑EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒。
❑PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒。
❑EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
❑PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。

虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。首先，EXPIRE命令可以转换成PEXPIRE命令：

```py
def EXPIRE(key, ttl_in_sec):
    #将TTl从秒转换成毫秒
    ttl_in_ms = sec_to_ms(ttl_in_sec)
    PEXPIRE(key, ttl_in_ms)
```

接着，PEXPIRE命令又可以转换成PEXPIREAT命令：

```py
def PEXPIRE(key, ttl_in_ms):
    #获取以毫秒计算的当前UNIX时间戳
    now_ms = get_current_unix_timestamp_in_ms()
    #当前时间加上TTL, 得出毫秒格式的键过期时间
    PEXPIREAT(key, now_ms+ttl_in_ms)
```

并且，EXPIREAT命令也可以转换成PEXPIREAT命令：

```py
def EXPIREAT(key, expire_time_in_sec):
    #将过期时间从秒转换为毫秒
    expire_time_in_ms = sec_to_ms(expire_time_in_sec)
    PEXPIREAT(key, expire_time_in_ms)
```

### 保存过期时间

redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：

❑过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。
❑过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

```c
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    // 过期字典, 保存着键的过期时间
    dict *expires;              /* Timeout of keys with a timeout set */
    ...
} redisDb;
```

图9-12展示了一个带有过期字典的数据库例子，在这个例子中，键空间保存了数据库中的所有键值对，而过期字典则保存了数据库键的过期时间。

**注意**
为了展示方便，图9-12的键空间和过期字典中重复出现了两次alphabet键对象和book键对象。在实际中，键空间的键和过期字典的键都指向同一个键对象，所以不会出现任何重复对象，也不会浪费任何空间。

图9-12中的过期字典保存了两个键值对：
❑第一个键值对的键为alphabet键对象，值为1385877600000，这表示数据库键alphabet的过期时间为1385877600000（2013年12月1日零时）。
❑第二个键值对的键为book键对象，值为1388556000000，这表示数据库键book的过期时间为1388556000000（2014年1月1日零时）。
当客户端执行PEXPIREAT命令（或者其他三个会转换成PEXPIREAT命令的命令）为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。
举个例子，如果数据库当前的状态如图9-12所示，那么在服务器执行以下命令之后：

    redis> PEXPIREAT message 1391234400000
    (integer) 1

过期字典将新增一个键值对，其中键为message键对象，而值则为1391234400000（2014年2月1日零时），如图9-13所示。

以下是PEXPIREAT命令的伪代码定义：

```py
def PEXPIREAT(key, expire_time_in_ms):
    #如果给定的键不存在于键空间, 那么不能设置过期时间
    if key not in redisDb.dict:
        return 0
    #在过期字典中关联键和过期时间
    redisDb.expires[key] = expire_time_in_ms
    #过期时间设置成功
    return 1
```

### 移除过期时间

PERSIST命令可以移除一个键的过期时间：

    redis> PEXPIREAT message 1391234400000
    (integer) 1
    redis> TTL message
    (integer) 13893281
    redis> PERSIST message
    (integer) 1
    redis> TTL message
    (integer) -1

PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。
举个例子，如果数据库当前的状态如图9-12所示，那么当服务器执行以下命令之后：

    redis> PERSIST book
    (integer) 1

数据库将更新成图9-14所示的状态。

可以看到，当PERSIST命令执行之后，过期字典中原来的book键值对消失了，这代表数据库键book的过期时间已经被移除。
以下是PERSIST命令的伪代码定义：

```py
def PERSIST(key):
    #如果键不存在, 或者键没有设置过期时间, 那么直接返回
    if key not in redisDb.expires:
        return 0
    #移除过期字典中给定键的键值对关联
    redisDb.expires.remove(key)
    #键的过期时间移除成功
    return 1
```

### 计算并返回剩余生存时间

TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：

    redis> PEXPIREAT alphabet 1385877600000
    (integer) 1
    redis> TTL alphabet
    (integer) 8549007
    redis> PTTL alphabet
    (integer) 8549001011

TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的，以下是这两个命令的伪代码实现：

```py
def PTTL(key):
    #键不存在于数据库
    if key not in redisDb.dict:
        return -2
    #尝试取得键的过期时间
    #如果键没有设置过期时间, 那么expire_time_in_ms将为None
    expire_time_in_ms = redisDb.expires.get(key)
    #键没有设置过期时间
    if expire_time_in_ms is None:
        return -1
    # 获取当前时间
    now_ms = get_current_unix_timestamp_in_ms()
    # 过期时间减去当前时间, 得出的差就是键的剩余生存时间
    return(expire_time_in_ms-now_ms)

def TTL(key):
    # 获取以毫秒为单位的剩余生存时间
    ttl_in_ms = PTTL(key)
    if ttl_in_ms < 0:
        # 处理返回值为-2和-1的情况
        return ttl_in_ms
    else:
        # 将毫秒转换为秒
        return ms_to_sec(ttl_in_ms)
```

举个例子，对于一个过期时间为1385877600000（2013年12月1日零时）的键alphabet来说：
❑如果当前时间为1383282000000（2013年11月1日零时），那么对键alphabet执行PTTL命令将返回2595600000，这个值是通过用alphabet键的过期时间减去当前时间计算得出的：1385877600000-1383282000000=2595600000。
❑另一方面，如果当前时间为1383282000000（2013年11月1日零时），那么对键alphabet执行TTL命令将返回2595600，这个值是通过计算alphabet键的过期时间减去当前时间的差，然后将差值从毫秒转换为秒之后得出的。
