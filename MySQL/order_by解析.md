在我们执行Mysql的Explain语句的时候，经常会看到这样的一个Using filesort。那么，Mysql的排序是在内存里面进行的，还是在磁盘里面进行的呢？假如我们是Mysql的设计者，我们会怎么做呢？首先，在内存里面来进行排序的速度，肯定是远远大于在磁盘中的。但是内存的资源毕竟有限，假如我们扫描到足够多的行，这个时候可能数据的大小已经超过内存，想在内存中进行排序是很困难的，这个时候我们只能够使用磁盘来进行排序了。

没错，Mysql也是这么设计的，Mysql有一个配置项，`sort_buffer_size`，如果我们Select到的数据量小于这个数，那么就会将数据在内存中进行排序，否则，Mysql就会把数据拆成很多个临时文件，每个临时文件的大小都会小于sort_buffer_size。也就是说，如果sort_buffer_size越小，拆分的临时文件就会越多，这也是为什么我们选来当存储的机器内存也要尽量大的原因。Mysql排序了多个临时文件之后，最后再做一次归并排序，就可以将所有记录排完了。

相信大家下面这样的话，如果你的数据库的列数比较多，那么尽量地不要使用`select *` 而是需要什么字段就只取什么字段，在数据库的排序中尤为如此。假如我们的数据列数特别多，满足条件的行数也多，这个时候，Mysql就不得不用更极端的排序算法进行排序，每一行数据，都只取主键id跟排序的字段。然后进行排序，最后，再取要满足条件的结果回表查询其他字段，然后返回结果。相对于原有上面的方案，这种Rowid的排序方式多了一次回表，所以查询效率大打折扣。

那么，我们有什么办法可以进行排序的优化呢？我们都知道，Innodb的索引实际上是一颗多叉排序树，那么假如我们能够在已有的排序树上取得结果，岂不美哉？！所以，如果我们要查询已经要排序的字段全都在已有的索引上，并且满足最左前缀原则，那么，我们就可以减少一次回表，从而大大提升效率。那么，如果判断你的Sql语句满足了这种优化呢？如果你的语句中含有OrderBy，但是Explain的结果却只有UseIndex，说明命中了索引覆盖。

当然，并不是所有的查询都要命中索引覆盖的，前面我们也提到了，维护索引是由代价的，还是需要具体问题具体分析。

## filesort排序

`sort_buffer_size`:一次性分配设置的内存,决定filesort排序分成多少个thread；

`max_length_for_sort_data`:决定采用双路还是单路排序

+ 双路排序：两次IO操作，省内存，费时间。排序采用快速排序，当sort buffer满了之后，放到临时文件中，最后利用归并算法排序；优化：对第二次操作，通过id进行IO取出要查询的字段，这时，对于第二次MySQL本身一个优化，即在捞之前首先将id排序(rowid)，并放入缓冲区，这个缓存区大小由参数`read_rnd_buffer_size`控制，然后有序去捞记录，将随机IO转为顺序IO。

+ 单路排序：一次取出所有的查询字段和排序字段，费内存，省时间。排序采用快速排序，当`sort buffer`满了之后，放到临时文件中，最后利用归并算法排序；

+ 堆排序： 针对order limit M,N设计的排序算法。堆排序是不稳定的。
