# 函数指针 & 指针函数

## 什么是函数指针

如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，**这段存储空间的首地址称为这个函数的地址**。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称*函数指针*。

那么这个指针变量怎么定义呢？虽然同样是指向一个地址，但指向函数的指针变量同我们之前讲的指向变量的指针变量的定义方式是不同的。例如：
```c++
int(*p)(int, int);
```
这个语句就定义了一个指向函数的指针变量 p。首先它是一个指针变量，所以要有一个“`*`”，即`(*p)`；其次前面的 int 表示这个指针变量可以指向返回值类型为 int 型的函数；后面括号中的两个 int 表示这个指针变量可以指向有两个参数且都是 int 型的函数。所以合起来这个语句的意思就是：定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为 `int(*)(int，int)`。

所以函数指针的定义方式为：

    函数返回值类型 (* 指针变量名) (函数参数列表);

“函数返回值类型”表示该指针变量可以指向具有什么返回值类型的函数；“函数参数列表”表示该指针变量可以指向具有什么参数列表的函数。这个参数列表中只需要写函数的参数类型即可。

我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“`(*指针变量名)`”。但是这里需要注意的是：“`(*指针变量名)`”两端的括号不能省略，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数。

那么怎么判断一个指针变量是指向变量的指针变量还是指向函数的指针变量呢？首先看变量名前面有没有“`*`”，如果有“`*`”说明是指针变量；其次看变量名的后面有没有带有形参类型的圆括号，如果有就是指向函数的指针变量，即函数指针，如果没有就是指向变量的指针变量。

最后需要注意的是，**指向函数的指针变量没有 ++ 和 -- 运算**。

## 如何用函数指针调用函数

给大家举一个例子：
```c++
int Func(int x);   /* 声明一个函数 */
int (*p) (int x);  /* 定义一个函数指针 */
p = Func;          /* 将Func函数的首地址赋给指针变量p */
```
赋值时函数 Func 不带括号，也不带参数。由于函数名 Func 代表函数的首地址，因此经过赋值以后，指针变量 p 就指向函数 Func() 代码的首地址了。

下面来写一个程序，看了这个程序你们就明白函数指针怎么使用了：
```c++
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

int Max(int, int);  //函数声明

int main(void) {
    int (*p)(int, int);  //定义一个函数指针
    int a, b, c;
    p = Max;  //把函数Max赋给指针变量p, 使p指向Max函数
    cout << "please enter a and b:" << endl;
    cin >> a >> b;
    c = p(a, b);  //通过函数指针调用Max函数
    // c = (*p)(a, b);
    //以上是一种等价写法
    cout << "max = " << c << endl;
    return 0;
}

int Max(int x, int y) { return x > y ? x : y; }
```
输出结果是：

    please enter a and b:
    1
    2
    max = 2

## 为什么要使用函数指针

那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。

举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。

## 回调函数

函数指针的一个非常典型的应用就是*回调函数*。

什么是回调函数？

回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。
回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。
同样我们来看一个回调函数的例子：

```c++
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

//函数功能：实现累加求和
int func_sum(int n) {
    int sum = 0;

    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}

//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数
int callback(int n, int (*p)(int)) { return p(n); }

int main(void) {
    int n = 0;
    cout << "please input number:" << endl;
    cin >> n;
    while (n < 0) {
        cout << "n must be > 0" << endl;
        cout << "please input number:" << endl;
        cin >> n;
    }
    //此处直接调用回调函数，而不是直接调用func_sum函数
    cout << "the sum is " << callback(n, func_sum) << endl;
    return 0;
}
```

上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数callback无需关心func_sum是怎么实现的，只需要去调用即可。
这样的好处就是，如果以后对求和函数有优化，比如新写了个func_sum2函数的实现，我们只需要在调用回调函数的地方将函数指针指向func_sum2即可，而无需去修改callback函数内部。

## 什么是指针函数

指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。其声明的形式如下所示：

    ret *func(args, ...);

其中，func是一个函数，args是形参列表，ret *作为一个整体，是func函数的返回值，是一个指针的形式。
