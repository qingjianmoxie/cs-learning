# 引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

## C++ 引用 vs 指针

引用很容易与指针混淆，它们之间有三个主要的不同：

+ 不存在空引用。引用必须连接到一块合法的内存。
+ 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
+ 引用必须在创建时被初始化。指针可以在任何时间被初始化。

## C++ 中创建引用

试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：
`int year = 2020;`
我们可以为 y 声明引用变量，如下所示：
`int& y = year;`
在这些声明中，& 读作引用。因此，第一个声明可以读作 "y 是一个初始化为 year 的整型引用".

## 引用的用途

+ 引用作为函数参数
+ 引用作为函数返回值

通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。

当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。例如，请看下面这个简单的程序：

```c++
#include <iostream>
using namespace std;

double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};

double &setValues(int i)
{
    return vals[i]; // 返回第 i 个元素的引用
}

// 要调用上面定义函数的主函数
int main()
{
    cout << "改变前的值" << endl;
    for (int i = 0; i < 5; i++)
    {
        cout << "vals[" << i << "] = ";
        cout << vals[i] << endl;
    }

    setValues(1) = 20.23; // 改变第 2 个元素
    setValues(3) = 70.8;  // 改变第 4 个元素

    cout << "改变后的值" << endl;
    for (int i = 0; i < 5; i++)
    {
        cout << "vals[" << i << "] = ";
        cout << vals[i] << endl;
    }
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

    改变前的值
    vals[0] = 10.1
    vals[1] = 12.6
    vals[2] = 33.1
    vals[3] = 24.1
    vals[4] = 50
    改变后的值
    vals[0] = 10.1
    vals[1] = 20.23
    vals[2] = 33.1
    vals[3] = 70.8
    vals[4] = 50

当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。
```c++
int &func()
{
    int q;
    //! return q; // 在编译时发生错误
    static int x;
    return x; // 安全，x 在函数作用域外依然是有效的
}
```