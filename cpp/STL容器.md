# STL容器

容器（container）用于存放数据的类模板。可变长数组、链表、平衡二叉树等数据结构在STL中都被实现为容器。

程序员使用容器时，即将容器类模板实例化为容器类时，会指明容器中存放的元素是什么类型的。

容器中可以存放基本类型的变量，也可以存放对象。对象或基本类型的变量被插入容器中时，实际插入的是对象或变量的一个**复制品**。

STL 中的许多算法（即函数模板），如排序、查找等算法，在执行过程中会对容器中的元素进行比较。这些算法在比较元素是否相等时通常用运算符进行，比较大小通常用`<`运算符进行，因此，被放入容器的对象所属的类最好重载`==`和`<`运算符，以使得两个对象用`==`和`<`进行比较是有定义的。

容器分为两大类。

## 顺序容器

一个容器就是一些特定类型对象的集合. **顺序容器(sequential container)**为程序员提供了控制元素存储和访问顺序的能力. 这种顺序不依赖于元素的值, 而是与元素加入容器时的位置相对应.

所有顺序容器都提供了快速顺序访问元素的能力. 但是, 这些容器在以下方面都有不同的性能折中:

+ 向容器添加或从容器中删除元素的代价
+ 非顺序访问容器中元素的代价

### 顺序容器类型

1. [vector](vector.md) : 可变大小数组. 支持快速随机访问. 在尾部之外的位置插入/删除元素可能很慢.
2. [deque](deque.md) : 双端队列. 支持快速随机访问. 在头尾位置插入/删除速度很快.
3. [list](list.md) : 双向链表. 只支持双向顺序访问. 在list中任何位置进行插入/删除操作速度都很快.
4. forward_list : 单向链表. 只支持单向顺序访问. 在链表任何位置进行插入/删除操作速度都很快.
5. array : 固定大小数组. 支持快速随机访问. 不能添加/删除元素.
6. string : 与vector相似的容器, 但专门用于保存字符. 随机访问快. 在尾部插入/删除速度快.

除了固定大小的array外, 其他容器都提供高效灵活的内存管理. 我们可以添加/删除元素, 扩张/收缩容器的大小. 容器的存储策略对容器操作的效率有着很大影响, 有时还会影响特定容器是否支持特定操作.

例如, string和vector将元素保存在连续的内存空间中. 由于元素是连续存储的, 由元素的下标来计算其地址非常快. 然而在中间位置添加/删除元素就会非常耗时: 在一次插入/删除操作后, 需要移动插入/删除位置之后的所有元素, 来保持连续存储. 而且, 添加一个元素有时候可能还需要分配额外的存储空间. 在这种情况下, 每个元素都必须移动到新的存储空间中.

list和forward_list这两个容器的设计目的是令容器任何位置的添加/删除操作都很快. 作为代价, 这两个容器不支持元素的随机访问: 为了访问一个元素, 我们只能遍历整个容器. 而且, 与vector, deque和array相比, 这两个容器的额外内存开销也很大.

### vector

`头文件<vector>`
动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能（大部分情况下是常数时间）。

### deque

`头文件<deque>`
双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（但是次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

### list

`头文件<list>`
双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。**不支持随机存取**。

## 关联容器

关联容器有以下四种：
+ set
+ multiset
+ map
+ multimap

关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。

默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用`<`运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。通常以平衡二叉树方式实现，插入和检索的时间都是O(log(N))。

### set/multiset

`头文件<set>`
set即集合。set中不允许存在相同的元素；而multiset中允许存在相同的元素。

### map/multimap

`头文件<map>`
map与set的不同之处在于map中存放的元素有且只有两个成员变量，一个名为first，另一个名为second。map根据first值对元素进行从小到大排序，并且可以快速地根据first来检索元素。
map同multimap的不同在于，map不允许有两个元素的first值相等，而multimap允许两个元素的first值相等。

## 容器适配器

除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：
+ 栈 stack
+ 队列 queue
+ 优先级队列 priority_queue

### stack

`头文件<stack>`
栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。**后进先出**。

### queue

`头文件<queue>`
队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。**先进先出**。

### priority_queue

`头文件<queue>`
优先级队列。最高优先级元素总是第一个出列。

-------------------------------------------

为称呼方便起见，本文后面将容器和容器适配器统称为容器。

容器都是**类模板**。它们实例化后就成为**容器类**。用容器类定义的对象称为**容器对象**。

例如，`vector<int>`是一个容器类的名字，`vector<int> a;`就定义了一个容器对象 a，a 代表一个长度可变的数组，数组中的每个元素都是 int 类型的变量；`vector<double> b;`定义了另一个容器对象 b，a 和 b 的类型是不同的。后文所说的“容器”，有时也指“容器对象”，需要根据上下文自行判断。

任何两个容器对象，只要它们的类型相同，就可以用 <、<=、>、>=、==、!= 进行词典式的比较运算。假设 a、b 是两个类型相同的容器对象，这些运算符的运算规则如下。

*   a == b：若 a 和 b 中的元素个数相同，且对应元素均相等，则`a == b`的值为 true，否则值为 false。元素是否相等是用`==`运算符进行判断的。
*   a<b：规则类似于词典中两个单词比较大小，从头到尾依次比较每个元素，如果发生 a 中的元素小于 b 中的元素的情况，则`a<b`的值为 true；如果没有发生 b 中的元素小于 a 中的元素的情况，且 a 中的元素个数比 b 少，`a<b`的值也为 true；其他情况下值为 false。元素比较大小是通过`<`运算符进行的。
*   a != b：等价于 !(a == b)。
*   a > b：等价于 b < a。
*   a <= b：等价于 !(b < a)。
*   a >= b：等价于 !(a < b)。

所有容器都有以下两个成员函数：

+  int size()：返回容器对象中元素的个数。
+  bool empty()：判断容器对象是否为空。

顺序容器和关联容器还有以下成员函数：

+  begin()：返回指向容器中第一个元素的迭代器。
+  end()：返回指向容器中最后一个元素**后面的位置**的迭代器。
+  rbegin()：返回指向容器中最后一个元素的反向迭代器。
+  rend()：返回指向容器中第一个元素前面的位置的反向迭代器。
+  erase(...)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。
+  clear()：从容器中删除所有元素。

如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。

顺序容器还有以下常用成员函数：

+  front()：返回容器中第一个元素的引用。
+  back()：返回容器中最后一个元素的引用。
+  push_back()：在容器末尾增加新元素。
+  pop_back()：删除容器末尾的元素。
+  insert(...)：插入一个或多个元素。该函数参数较复杂，此处省略。

## 链接

- [目录](README.md)
- 上一节：[STL标准模板库](./STL标准模板库.md)
- 下一章：[STL迭代器 iterator](./STL迭代器iterator.md)