# STL中“大”、“小”和“相等”的概念

STL 中关联容器内部的元素是从小到大排序的。STL 中的许多算法也涉及排序、查找。这些容器和算法都需要对元素进行比较，有的比较是否相等，有的比较元素大小。

有些算法要求其操作的区间是从小到大排序的，称为“有序区间算法”，比如binary_search。
有些算法会对区间进行从小到大排序，称为“排序算法”，比如sort。
（从小到大是由程序员自己定义的）。

在 STL 中，默认情况下，比较大小是通过<运算符进行的，和>运算符无关。在STL中提到“大”、“小”的概念时，在缺省的情况下，以下三个说法是等价的：
* x 比 y 小。
* 表达式`x<y`为真。
* y 比 x 大。

一定要注意，`y比x大`意味着`x<y为真`，而不是`y>x为真`。`y>x`的结果如何并不重要，甚至`y>x`是没定义的都没有关系。

在 STL 中，`x和y相等`也往往不等价于`x==y为真`。对于在未排序的区间上进行的算法，如顺序查找算法 find，查找过程中比较两个元素是否相等用的是==运算符；但是对于在排好序的区间上进行查找、合并等操作的算法（如折半查找算法 binary_search，关联容器自身的成员函数 find）来说，`x和y相等`是与`x小于y和y小于x同时为假`等价的，与==运算符无关。看上去`x小于y和y小于x同时为假`就应该和`x==y为真`等价，其实不然。例如下面的 class A：
```c++
#include <iostream>
#include <algorithm>
using namespace std;
class A
{
    int v;

public:
    A(int n) : v(n) {}
    bool operator<(const A &a2) const
    {
        cout << v << "<" << a2.v << "?" << endl;
        return false;
    }
    bool operator==(const A &a2) const
    {
        cout << v << "==" << a2.v << "?" << endl;
        return v == a2.v;
    }
};
int main()
{
    A a[] = {A(1), A(2), A(3), A(4), A(5)};
    cout << binary_search(a, a + 4, A(9));
    return 0;
}
```
输出为
3<9?
2<9?
1<9?
9<1?
1

可以看到，对任意两个类 A 的对象 x、y，`x<y`和`y<x`都是为假的。折半查找binary_search判断`x<y`和`y<x`都是为假时，则认为x与y是相等的，这与==运算符的行为无关。

综上所述，使用 STL 中的关联容器和许多算法时，往往需要对<运算符进行适当的重载，使得这些容器和算法可以用<运算符对所操作的元素进行比较。最好将<运算符重载为全局函数，因为在重载为成员函数时，在有些编译器上会出错（由其 STL 源代码的写法导致）。