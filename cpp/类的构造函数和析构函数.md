# 类的构造函数

每个类都定义了它的对象被初始化的方式, 类通过一个或几个特殊的成员函数来控制其对象的初始化过程, 这些函数叫做**构造函数(constructor)**. 构造函数的任务是初始化类对象的数据成员, 无论何时只要类的对象被创建, 就会执行构造函数.

构造函数的名字与类名是相同的. 与其他函数不一样的是, 构造函数没有返回类型，也不会返回 void。

不同于其他成员函数, 构造函数不能被声明成const. 当我们创建类的一个const对象时, 直到构造函数完成初始化过程, 对象才能真正取得其"常量"属性. 因此, 构造函数在const对象的构造过程中可以向其写值.

## 默认构造函数

类通过一个特殊的构造函数来控制默认初始化过程, 这个函数叫做**默认构造函数(default constructor)**. 默认构造函数无须任何实参. 如果我们的类没有显式地定义构造函数, 那么编译器就会为我们隐式地定义一个默认构造函数.

编译器创建的构造函数又被称为**合成的默认构造函数(synthesized default constructor)**. 合成的默认构造函数将按照如下规则初始化类的数据成员:

+ 如果存在类内的初始值, 用它来初始化成员.
+ 否则, 默认初始化该成员.

我们不能依赖合成的默认构造函数, 必须定义类自己的默认构造函数. 原因如下:

1. 第一个原因是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数. 一旦我们定义了一些其他的构造函数, 那么除非我们再定义一个默认的构造函数, 否则类将没有默认构造函数. 这条规则的依据是, 如果一个类在某种情况下需要控制对象初始化, 那么该类很可能在所有情况下都需要控制.

2. 第二个原因是对于某些类来说, 合成的默认构造函数可能执行错误的操作. 类内的内置类型或复合类型(比如数组和指针)的成员被默认初始化时, 它们的值是未定义的.

## 构造函数初始值列表

使用构造函数初始值列表来初始化字段：
```c++
Line::Line(double len) : length(len) { }
```
上面的语法等同于如下语法：
```c++
Line::Line(double len)
{
    length = len;
}
```
假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：
```c++
C::C(double a, double b, double c) : X(a), Y(b), Z(c) { }
```

# 拷贝、赋值和析构

如果我们不主动定义拷贝、赋值和析构这些操作, 编译器会替我们合成它们. 一般来说, 编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作.

但是必须要清楚的一点是, 对于某些类来说, 合成的版本无法正常工作. 特别是, 当类需要分配类对象之外的资源时, 合成的版本常常会失效. 举个栗子, 管理动态内存的类通常不能依赖于上述操作的合成版本.

不过, 很多需要动态内存的类能(而且应该)使用vector对象或者string对象管理必要的存储空间. 使用vector或者string的类能避免分配内存和释放内存带来的复杂性.


# 类的析构函数

类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号 `~` 作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
