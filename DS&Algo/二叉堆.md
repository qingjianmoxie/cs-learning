# 二叉堆(Binary Heap)

## 二叉堆的定义

首先，二叉堆和二叉树有啥关系呢，为什么人们总数把二叉堆画成一棵二叉树？

因为，二叉堆其实是完全二叉树或近似完全二叉树，只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针.

当父节点的值总是大于等于任何一个子节点的值时为**最大堆**。 当父节点的值总是小于等于任何一个子节点的值时为**最小堆**。

二叉堆的主要操作就两个，`sink`（下沉）和 `swim`（上浮），用以维护二叉堆的性质。其主要应用有两个，其一是「堆排序」，其二是数据结构「优先级队列」。

## 二叉堆的存储

如前文所述, 二叉堆一般使用**数组**来表示。请回忆一下二叉树的性质，其中有一条性质：

性质五：如果对一棵有n个节点的完全二叉树的节点按层序编号（从第一层开始到最下一层，每一层从左到右编号，从1开始编号），对任一节点i有：
1. 如果i=1 ，则节点为根节点，没有双亲。
2. 如果`2*i > n` ，则节点i没有左孩子 ；否则其左孩子节点为`2*i`. （n为节点总数）
3. 如果`2*i + 1 > n` ，则节点i没有右孩子；否则其右孩子节点为`2*i+1`

简单来说:
1. 如果根节点在数组中的位置是1，第n个位置的子节点分别在2n 与 2n+1，第n个位置的双亲节点在`i/2`。因此，第1个位置的子节点在2和3.
2. 如果根节点在数组中的位置是0，第n个位置的子节点分别在2n+1与2n+2，第n个位置的双亲节点在`(i-1)/2`。因此，第0个位置的子节点在1和2.

得益于数组的随机存储能力，我们能够很快确定堆中节点的父节点与子节点。

画个图你立即就能理解了，此处根节点的位置为0，

        i   0  1  2  3  4  5  6
    arr[i]  A  B  C  D  E  F  G

           A       堆顶
          / \
         B   C
        / \ / \
       D  E F  G   堆底

PS：因为数组索引是数组，为了方便区分，将字符作为数组元素。

你看到了，把 arr[0] 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。为了方便讲解，下面画的图都是二叉树结构，相信你能把树和数组对应起来。

## 最大堆的实现

[最大堆的实现](./src/max_heap/max_heap.h)
[最大堆的测试代码](./src/max_heap/max_heap.cc)

运行结果：

    9 8 5 6 7 1 4 0 3 2
    9 7 5 6 2 1 4 0 3
    10 9 6 7 8 2 5 1 4 3

## 总结

二叉堆就是一种完全二叉树，所以适合存储在数组中，而且二叉堆拥有一些特殊性质。

优先级队列是基于二叉堆实现的，主要操作是插入和删除。插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。

[目录](README.md)
