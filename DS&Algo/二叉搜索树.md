# 二叉搜索树
二叉搜索树(BST, Binary Search Tree)，也称二叉排序树或二叉查找树。
二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：
1. 非空左子树的所有键值小于其根结点的键值。
2. 非空右子树的所有键值大于其根结点的键值。
3. 左、右子树都是二叉搜索树。

注意这个定义排除了树中存在值相同的节点的可能性.

[头文件](../code/binary_search_tree.h)
[源文件](../code/binary_search_tree.c)

## 二叉搜索树的查找操作Find

其基本算法如下:
    如果树为空:
        查找失败
    否则:
        如果这个值等于当前节点的值:
            查找成功
        否则:
            如果这个值小于当前节点的值:
                搜索左子树
            否则:
                搜索右子树

```c++
TreeNode *find(ElementType value, BinTree root)
{
    if (NULL == root) {
        // 没有找到
        return NULL;
    }
    if (value > root->val) {
        // 在右子树中继续查找
        return find(value, root->right);
    } else if (value < root->val) {
        // 在左子树中继续查找
        return find(value, root->left);
    } else {
        // 查找成功, 返回找到的节点
        return root;
    }
}
```
这个递归算法属于尾部递归。由于非递归函数的执行效率高，可将"尾部递归"函数改为迭代函数。

```c++
TreeNode *find(ElementType value, BinTree root)
{
    TreeNode *current = root;

    while (NULL != current) {
        if (value < current->val) {
            current = current->left;
        } else if (value > current->val) {
            current = current->right;
        } else {
            return current;
        }
    }
    return NULL;
}
```
查找的效率决定于树的高度。

## 查找最大和最小元素
* 最大元素一定是在树的最右分枝的端结点上;
* 最小元素一定是在树的最左分枝的端结点上.

查找最小元素的递归函数:
```c
TreeNode *FindMin(BinTree root)
{
    if (!root)
        return NULL; /*空的二叉搜索树，返回NULL*/
    else if (!root->left)
        return root; /*找到最左叶结点并返回*/
    else
        return FindMin(root->left); /*沿左分支继续查找*/
}
```

查找最大元素的迭代函数:
```c
TreeNode *FindMax(BinTree root)
{
    if (root)
        while (root->right)
            root = root->right;
    /*沿右分支继续查找，直到最右叶结点*/
    return root;
}
```

## 二叉搜索树的插入

其基本算法如下:
    如果树为空:
        把新值作为根节点插入
    否则:
        如果新值等于当前节点的值:
            返回
        否则:
            如果新值小于当前节点的值:
                把新值插入到当前节点的左子树
            否则:
                把新值插入到当前节点的右子树

## 二叉搜索树的删除

在二叉搜索树中删除一个节点, 分三种情况讨论：
* 要删除的是叶结点： 直接删除， 并再修改其父结点指针---置为NULL.
* 要删除的结点只有一个孩子结点: 将其父结点的指针指向要删除结点的孩子结点.
* 要删除的结点有左、右两棵子树: 用另一结点替代被删除结点： 右子树的最小元素 或者 左子树的最大元素
```c++
TreeNode *Delete(ElementType value, BinTree root) {
    TreeNode *current;
    if (NULL == root) {
        printf("要删除的元素未找到");
    } else if (value < root->val) {
        root->left = Delete(value, root->left); /* 左子树递归删除 */
    } else if (value > root->val) {
        root->right = Delete(value, root->right); /* 右子树递归删除 */
    } else {
        /*找到要删除的结点 */
        if (root->left && root->right) {
            /*被删除结点有左右两个子结点 */
            current = FindMin(root->right);
            /*在右子树中找最小的元素填充删除结点*/
            root->val = current->val;
            /*在删除结点的右子树中删除最小元素*/
            root->right = Delete(root->val, root->right);
        } else {
            /*被删除结点有一个或无子结点*/
            current = root;
            if (NULL == root->left) /* 有右孩子或无子结点*/
                root = root->right;
            else if (NULL == root->right) /*有左孩子或无子结点*/
                root = root->left;
        }
    }
    return root;
}
```
