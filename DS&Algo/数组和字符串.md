# 数组和字符串
- [数组和字符串](#数组和字符串)
  - [概述](#概述)
  - [数组简介](#数组简介)
    - [集合、列表和数组](#集合列表和数组)
    - [数组的操作](#数组的操作)
    - [合并区间](#合并区间)
  - [二维数组简介](#二维数组简介)
    - [二维数组简介](#二维数组简介-1)
    - [旋转矩阵](#旋转矩阵)
    - [零矩阵](#零矩阵)
    - [对角线遍历](#对角线遍历)
  - [字符串简介](#字符串简介)
    - [字符串简介](#字符串简介-1)
    - [最长公共前缀](#最长公共前缀)

## 概述

数组 是数据结构中的基本模块之一。因为 字符串 是由字符数组形成的，所以二者是相似的。大多数面试问题都属于这个范畴。

在本 LeetBook 中，我们将介绍 数组 和 字符串。完成后，你将：

1. 理解数组的 基本概念 及其 操作方式；
2. 理解 二维数组 的基本概念，熟悉二维数组的使用；
3. 了解 字符串 的概念以及字符串所具有的不同特性；
4. 理解字符串匹配中的 KMP 算法；
5. 能够运用 双指针 解决实际问题。

## 数组简介

本章节中，我们将详细介绍 数组 这种数据结构。

完成本章后，你将能够回答以下问题：

1. 数组和列表、集合之间有什么不同？
2. 如何理解数组的读取、查找、插入、删除等 基本操作？
3. 数组在内存中是如何存放的？
4. 在你常用的语言中，如何对数组执行初始化、数据访问、修改、迭代、排序、添加、删除等操作？

### 集合、列表和数组

> 本文中介绍的概念为适用于所有编程语言的抽象理论，具体实现会由编程语言的不同而稍有差别。

具体介绍数组之前，我们先来了解一下集合、列表和数组的概念之间的差别。

**集合**

集合一般被定义为：由一个或多个确定的元素所构成的整体。

通俗来讲，集合就是将一组事物组合在一起。你可以将力扣的题库看作一个集合, 也可以将力扣商店里的礼品看作一个集合, 甚至可以将桌面上的物品当作一个集合。

集合有什么特性呢？

首先，**集合里的元素类型不一定相同**。 你可以将商品看作一个集合，也可以将整个商店看作一个集合，这个商店中有人或者其他物品也没有关系。

其次，**集合里的元素没有顺序**。 我们不会这样讲：我想要集合中的第三个元素，因为集合是没有顺序的。

事实上，这样的集合并不直接存在于编程语言中。然而，实际编程语言中的很多数据结构，就是在集合的基础上添加了一些规则形成的。

**列表**

列表（又称线性列表）的定义为：是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。

列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。你可以把它看作一张购物清单：

    购物清单
    1. 一本算法书
    2. 一个笔记本
    3. 两包咖啡

在这张清单中：

+ 购物清单中的条目代表的类型可能不同，但是按照一定顺序进行了排列；
+ 购物清单的长度是可变的，你可以向购物清单中增加、删除条目。

在编程语言中，列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表。除此之外，向列表中添加、删除元素的具体实现方式会根据编程语言的不同而有所区分。

**数组**

数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。

正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。

那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：**索引**。

首先，数组会用一些名为 索引 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 0 算起的。我们可以根据数组中的索引，快速访问数组中的元素。

    idx   0   1   2   3   4   5   6   7   
        +---+---+---+---+---+---+---+---+
        |   |   |   |   |   |   |   |   |
        +---+---+---+---+---+---+---+---+

而列表中没有索引，这是数组与列表最大的不同点。

其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。要理解这一点，我们需要了解数组在内存中的存储方式，我们将在下一节中详细介绍。

![](https://pic.leetcode-cn.com/7b17543e4e39ae894bba0b2b6f8431b40d3df04556df06a3b974146d9e5c7d0d-5.png)

相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。有关链表的介绍，可以在探索卡片「链表」中进行进一步学习。

以上就是集合、列表和数组的介绍，你能自己总结出它们的不同点吗？

### 数组的操作

本节我们重点来讲解一下数组的 4 种操作。

**读取元素**

读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始。

在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。

而对于数组，计算机会在内存中为其申请一段 **连续** 的空间，并且会记下索引为 0 处的内存地址。以数组 ["C", "O", "D", "E", "R"] 为例，它的各元素对应的索引及内存地址如下图所示。

![](https://pic.leetcode-cn.com/273ac74bdd7a19d72c2bf60d84ddd66f09b45de4d8c36333bf5f1fee2c7a8330-%E5%9B%BE%E7%89%872.png)

假如我们想要访问索引为 2 处的元素 "D" 时，计算机会进行以下计算：

+ 找到该数组的索引 0 的内存地址： 2008；
+ 将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 = 2010，对应的元素为 "D"，这时便找到了目标元素。

我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 O(1)。

**查找元素**

假如我们对数组中包含哪些元素并不了解，只是想知道其中是否含有元素 "E"，数组会如何查找元素 `"E" 呢？

与读取元素类似，由于我们只保存了索引为 0 处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾。

我们发现，最坏情况下，搜索的元素为 "R"，或者数组中不包含目标元素时，我们需要查找 n 次，n 为数组的长度，因此查找元素的时间复杂度为 O(N)。

**插入元素**

假如我们想在原有的数组中再插入一个元素 "S" 呢？

如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。

然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 **腾出** 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 "S"。

我们发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题，我们将在另外的卡片中进行学习。

**删除元素**

删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 **空缺** 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 **填补** 操作。

以删除索引 1 中的元素 "O" 为例，具体过程如图所示。

![](https://pic.leetcode-cn.com/4df7a5a75e5f76b6e7e4540f9403c7c2fee5197a1f30421b4f5d32fdca2cf360-8.gif)

当数组的长度为 n 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 1 + (n - 1) = n 步，其中，1 为删除操作，n - 1 为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为 O(N)，N 为数组的长度。

### 合并区间

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

    输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
    输出: [[1,6],[8,10],[15,18]]
    解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

    输入: intervals = [[1,4],[4,5]]
    输出: [[1,5]]
    解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。

提示：

+ intervals[i][0] <= intervals[i][1]

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {

    }
};
```

**思路**:

先按首位置进行排序;

接下来,如何判断两个区间是否重叠呢?比如 a = [1,4],b = [2,3]

当 a[1] >= b[0] 说明两个区间有重叠.

但是如何把这个区间找出来呢?

左边位置一定是确定，就是 a[0]，而右边位置是 max(a[1], b[1])

所以,我们就能找出整个区间为:[1,4]

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if not intervals: return []
        intervals.sort()
        res = [intervals[0]]
        for x, y in intervals[1:]:
            if res[-1][1] < x:
                res.append([x, y])
            else:
                res[-1][1] = max(y, res[-1][1])
        return res
```

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>> &intervals) {
        vector<vector<int>> res;
        int size = intervals.size();
        if (0 == size) return res;
        sort(intervals.begin(), intervals.end());
        res.push_back(intervals[0]);
        int i(0), j(1);
        while (j < size) {
            if (res[i][1] < intervals[j][0]) {
                res.push_back(intervals[j]);
                ++i;
            } else {
                res[i][1] = max(res[i][1], intervals[j][1]);
            }
            ++j;
        }
        return res;
    }
};
```

## 二维数组简介

前面的章节中，我们已经了解了 一维数组。然而，有时候，我们可能需要用到 多维数组，它更适合像表或矩阵这样更复杂的结构。

本章节中，我们将重点围绕二维数组来解释：

1. 二维数组在内存中是如何存放的？
2. 如何运用二维数组来解决问题？

### 二维数组简介

二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。

![](https://pic.leetcode-cn.com/e64116dc9c9c8f9f8ad2a5c251c0e76a677ba874a3bab0e22ce164384237a55c-1.png)

所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。

**示例**

类似一维数组，对于一个二维数组 A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 **连续** 的空间，并记录第一行数组的索引位置，即 A[0][0] 的内存地址，它的索引与内存地址的关系如下图所示。

![](https://pic.leetcode-cn.com/bf1bd2a80e026f8ce335724e54a457301f5909cfd8ae5a25f8d2692c7cdae720-2.png)

注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 1。

实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。

### 旋转矩阵

给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

示例 1:

    给定 matrix = 
    [
      [1,2,3],
      [4,5,6],
      [7,8,9]
    ],

    原地旋转输入矩阵，使其变为:
    [
      [7,4,1],
      [8,5,2],
      [9,6,3]
    ]

示例 2:

    给定 matrix =
    [
      [ 5, 1, 9,11],
      [ 2, 4, 8,10],
      [13, 3, 6, 7],
      [15,14,12,16]
    ], 

    原地旋转输入矩阵，使其变为:
    [
      [15,13, 2, 5],
      [14, 3, 4, 1],
      [12, 6, 8, 9],
      [16, 7,10,11]
    ]

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {

    }
};
```

思路上总体是对的, 以示例2为例, 我想的需要旋转的数是第一行的5,1,9 和第二行的4, 那么计算会很麻烦. 实际上是把矩阵分为四块, 需要旋转的数是[[5,1],[2,4]]这一块, 这样规律就明显了.

```c++
class Solution {
public:
    void rotate(vector<vector<int>> &matrix) {
        int n = matrix.size();
        if (0 == n) return;
        int row = (n >> 1) - 1;  // 左上角区域的最大行下标
        int column = (n - 1) >> 1;  // 左上角区域的最大列下标，行列下标从 0 开始
        for (int i = row; i >= 0; --i) {
            for (int j = column; j >= 0; --j) {
                swap(matrix[i][j], matrix[j][n - 1 - i]);
                swap(matrix[i][j], matrix[n - 1 - i][n - 1 - j]);
                swap(matrix[i][j], matrix[n - 1 - j][i]);
            }
        }
    }
};
```

### 零矩阵
编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

示例 1：

    输入：
    [
      [1,1,1],
      [1,0,1],
      [1,1,1]
    ]
    输出：
    [
      [1,0,1],
      [0,0,0],
      [1,0,1]
    ]

示例 2：

    输入：
    [
      [0,1,2,0],
      [3,4,5,2],
      [1,3,1,5]
    ]
    输出：
    [
      [0,0,0,0],
      [0,4,5,0],
      [0,3,1,0]
    ]

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {

    }
};
```

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>> &matrix) {
        set<int> r;
        set<int> c;
        int m = matrix.size();
        if (0 == m) return;
        int n = matrix[0].size();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (0 == matrix[i][j]) {
                    r.insert(i);
                    c.insert(j);
                }
            }
        }
        for (int i : r) {
            for (int j = 0; j < n; ++j) {
                matrix[i][j] = 0;
            }
        }
        for (int j : c) {
            for (int i = 0; i < m; ++i) {
                matrix[i][j] = 0;
            }
        }
    }
};
```

### 对角线遍历

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:

    输入:
    [
     [ 1, 2, 3 ],
     [ 4, 5, 6 ],
     [ 7, 8, 9 ]
    ]

    输出:  [1,2,4,7,5,3,6,8,9]

解释:
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png)

说明:

1. 给定矩阵中的元素总数不会超过 100000 。

```c++
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {

    }
};
```

```c++
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>> &matrix) {
        vector<int> res;
        int m = matrix.size();
        if (0 == m) return res;
        int n = matrix[0].size();
        if (0 == n) return res;
        bool flag = true;
        for (int sum = 0; sum < m + n - 1; ++sum) {
            if (flag) {
                int x = (sum < m) ? sum : m - 1;
                int y = sum - x;
                while (x >= 0 && y < n) {
                    res.push_back(matrix[x][y]);
                    --x;
                    ++y;
                }
            } else {
                int y = (sum < n) ? sum : n - 1;
                int x = sum - y;
                while (y >= 0 && x < m) {
                    res.push_back(matrix[x][y]);
                    ++x;
                    --y;
                }
            }
            flag = !flag;
        }
        return res;
    }
};
```

## 字符串简介

正如我们在概述中提到的那样，字符串是一个由字符构成的数组。

本章节中，我们将深入研究字符串。完成本章后，你将：

+ 熟悉字符串中的 基本操作，尤其是在数组中没有的独特操作；
+ 理解不同 比较 函数之间的区别；
+ 理解字符串 是否可变 以及导致连接过程中出现的问题；
+ 能够解决与字符串相关的基本问题，如排序、子串、字符串匹配等。

### 字符串简介

> 维基百科：字符串是由零个或多个字符组成的有限序列。一般记为 s = a1a2...an。它是编程语言中表示文本的数据类型。

**为何单独讨论字符串类型**

我们知道，字符串与数组有很多相似之处，比如使用 `名称[下标]` 来得到一个字符。那么我们为什么要单独讨论字符串呢？原因主要有：

1. 字符串的基本操作对象通常是*字符串整体或者其子串*

例如有这样一个字符串序列：`I like leetcode` 现在你想把这句话反向输出，可能会变成这样：

    edocteel ekil I

这是我们想要的结果吗？你可能会回答不是，因为它没有任何意义。我们通常希望单词仍然维持原来的顺序，这样反向输出之后就是：

    Leetcode like I

这样的结果对于我们来讲是不是更满意呢？维持单词本身的顺序使得我们方便进行更多操作，这里的每个单词就叫做字符串的「子串」，通常，我们的操作对象更多情况下是这些子串。

2. 字符串操作比其他数据类型更复杂（*例如比较、连接操作*）

对于不同的编程语言，字符串的某些操作会有所不同。下面我们将从字符串的「比较」和「连接」操作两个方面份别进行讲解。

**比较函数**

字符串有它自己的比较函数（我们将在下面的代码中向你展示比较函数的用法）。

然而，存在这样一个问题：

> 我们可以用 “==” 来比较两个字符串吗？

这取决于下面这个问题的答案：

> 我们使用的语言是否支持运算符重载？

+ 如果答案是 yes （例如 C++、Python）。我们可以使用 == 来比较两个字符串；
+ 如果答案是 no （例如 Java），我们可能无法使用 == 来比较两个字符串。当我们使用 == 时，它实际上会比较这两个对象是否是同一个对象。

你可以运行下面的例子来比较结果：

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1 = "Hello World";
    cout << "s1 is \"Hello World\"" << endl;
    string s2 = s1;
    cout << "s2 is initialized by s1" << endl;
    string s3(s1);
    cout << "s3 is initialized by s1" << endl;
    // compare by '=='
    cout << "Compared by '==':" << endl;
    cout << "s1 and \"Hello World\": " << (s1 == "Hello World") << endl;
    cout << "s1 and s2: " << (s1 == s2) << endl;
    cout << "s1 and s3: " << (s1 == s3) << endl;
    // compare by 'compare'
    cout << "Compared by 'compare':" << endl;
    cout << "s1 and \"Hello World\": " << !s1.compare("Hello World") << endl;
    cout << "s1 and s2: " << !s1.compare(s2) << endl;
    cout << "s1 and s3: " << !s1.compare(s3) << endl;
}
```

**连接操作**

对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。不可变意味着一旦字符串被初始化，你就无法改变它的内容。

+ 在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。
+ 在其他一些语言（如 Java、Python）中，字符串是不可变的。

你可以通过测试修改操作来确定你喜欢的语言中的字符串是否可变。

在 **字符串不可变** 的语言中，进行字符串的连接操作则会带来一些问题。

显然，不可变字符串无法被修改。哪怕你只是想修改其中的一个字符，也必须创建一个新的字符串。我们以 Java 为例，来看一个在 for 循环中重复进行字符串连接的例子：

```c++
#include <iostream>

int main() {
    string s = "";
    int n = 10000;
    for (int i = 0; i < n; i++) {
        s += "hello";
    }
}
```

```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        String s = "";
        int n = 10000;
        for (int i = 0; i < n; i++) {
            s += "hello";
        }
    }
}
```

我们发现在 C++ 中，进行字符串连接并没有明显的性能影响。

然而，对于 Java来说，由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串。

因此，总时间复杂度将是：

5 + 5 × 2 + 5 × 3 + … + 5 × n = 5 × (1 + 2 + 3 + … + n) = 5 × n × (n + 1) / 2
即 O(N^2)。

针对 Java 中出现的此问题，我们提供了以下解决方案：

+ 如果你确实希望你的字符串是可变的，则可以使用 toCharArray 将其转换为字符数组。
+ 如果你经常必须连接字符串，最好使用一些其他的数据结构，如 StringBuilder 。

### 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

    输入: ["flower","flow","flight"]
    输出: "fl"

示例 2:

    输入: ["dog","racecar","car"]
    输出: ""
    解释: 输入不存在公共前缀。

说明:

所有输入只包含小写字母 a-z 。

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        
    }
};
```

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string> &strs) {
        int size = strs.size();
        if (0 == size) return "";
        int max_len = strs[0].size();
        int m = strs[0].size();
        for (int idx = 1; idx < size; ++idx) {
            int n = strs[idx].size();
            int i(0);
            while (i < max_len && i < n) {
                if (strs[0][i] == strs[idx][i]) {
                    ++i;
                } else {
                    break;
                }
            }
            if (0 == i) return "";
            max_len = min(max_len, i);
        }
        return strs[0].substr(0, max_len);
    }
};
```