# 数组和字符串
- [数组和字符串](#数组和字符串)
  - [概述](#概述)
  - [数组简介](#数组简介)
    - [集合、列表和数组](#集合列表和数组)
    - [数组的操作](#数组的操作)
    - [合并区间](#合并区间)
  - [二维数组简介](#二维数组简介)
    - [二维数组简介](#二维数组简介-1)
    - [旋转矩阵](#旋转矩阵)
    - [零矩阵](#零矩阵)
    - [对角线遍历](#对角线遍历)
  - [字符串简介](#字符串简介)
    - [字符串简介](#字符串简介-1)
    - [最长公共前缀](#最长公共前缀)
    - [翻转字符串里的单词](#翻转字符串里的单词)
    - [字符串匹配算法：KMP](#字符串匹配算法kmp)

## 概述

数组 是数据结构中的基本模块之一。因为 字符串 是由字符数组形成的，所以二者是相似的。大多数面试问题都属于这个范畴。

在本 LeetBook 中，我们将介绍 数组 和 字符串。完成后，你将：

1. 理解数组的 基本概念 及其 操作方式；
2. 理解 二维数组 的基本概念，熟悉二维数组的使用；
3. 了解 字符串 的概念以及字符串所具有的不同特性；
4. 理解字符串匹配中的 KMP 算法；
5. 能够运用 双指针 解决实际问题。

## 数组简介

本章节中，我们将详细介绍 数组 这种数据结构。

完成本章后，你将能够回答以下问题：

1. 数组和列表、集合之间有什么不同？
2. 如何理解数组的读取、查找、插入、删除等 基本操作？
3. 数组在内存中是如何存放的？
4. 在你常用的语言中，如何对数组执行初始化、数据访问、修改、迭代、排序、添加、删除等操作？

### 集合、列表和数组

> 本文中介绍的概念为适用于所有编程语言的抽象理论，具体实现会由编程语言的不同而稍有差别。

具体介绍数组之前，我们先来了解一下集合、列表和数组的概念之间的差别。

**集合**

集合一般被定义为：由一个或多个确定的元素所构成的整体。

通俗来讲，集合就是将一组事物组合在一起。你可以将力扣的题库看作一个集合, 也可以将力扣商店里的礼品看作一个集合, 甚至可以将桌面上的物品当作一个集合。

集合有什么特性呢？

首先，**集合里的元素类型不一定相同**。 你可以将商品看作一个集合，也可以将整个商店看作一个集合，这个商店中有人或者其他物品也没有关系。

其次，**集合里的元素没有顺序**。 我们不会这样讲：我想要集合中的第三个元素，因为集合是没有顺序的。

事实上，这样的集合并不直接存在于编程语言中。然而，实际编程语言中的很多数据结构，就是在集合的基础上添加了一些规则形成的。

**列表**

列表（又称线性列表）的定义为：是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。

列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。你可以把它看作一张购物清单：

    购物清单
    1. 一本算法书
    2. 一个笔记本
    3. 两包咖啡

在这张清单中：

+ 购物清单中的条目代表的类型可能不同，但是按照一定顺序进行了排列；
+ 购物清单的长度是可变的，你可以向购物清单中增加、删除条目。

在编程语言中，列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表。除此之外，向列表中添加、删除元素的具体实现方式会根据编程语言的不同而有所区分。

**数组**

数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。

正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。

那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：**索引**。

首先，数组会用一些名为 索引 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 0 算起的。我们可以根据数组中的索引，快速访问数组中的元素。

    idx   0   1   2   3   4   5   6   7   
        +---+---+---+---+---+---+---+---+
        |   |   |   |   |   |   |   |   |
        +---+---+---+---+---+---+---+---+

而列表中没有索引，这是数组与列表最大的不同点。

其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。要理解这一点，我们需要了解数组在内存中的存储方式，我们将在下一节中详细介绍。

![](https://pic.leetcode-cn.com/7b17543e4e39ae894bba0b2b6f8431b40d3df04556df06a3b974146d9e5c7d0d-5.png)

相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。有关链表的介绍，可以在探索卡片「链表」中进行进一步学习。

以上就是集合、列表和数组的介绍，你能自己总结出它们的不同点吗？

### 数组的操作

本节我们重点来讲解一下数组的 4 种操作。

**读取元素**

读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始。

在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。

而对于数组，计算机会在内存中为其申请一段 **连续** 的空间，并且会记下索引为 0 处的内存地址。以数组 ["C", "O", "D", "E", "R"] 为例，它的各元素对应的索引及内存地址如下图所示。

![](https://pic.leetcode-cn.com/273ac74bdd7a19d72c2bf60d84ddd66f09b45de4d8c36333bf5f1fee2c7a8330-%E5%9B%BE%E7%89%872.png)

假如我们想要访问索引为 2 处的元素 "D" 时，计算机会进行以下计算：

+ 找到该数组的索引 0 的内存地址： 2008；
+ 将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 = 2010，对应的元素为 "D"，这时便找到了目标元素。

我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 O(1)。

**查找元素**

假如我们对数组中包含哪些元素并不了解，只是想知道其中是否含有元素 "E"，数组会如何查找元素 `"E" 呢？

与读取元素类似，由于我们只保存了索引为 0 处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾。

我们发现，最坏情况下，搜索的元素为 "R"，或者数组中不包含目标元素时，我们需要查找 n 次，n 为数组的长度，因此查找元素的时间复杂度为 O(N)。

**插入元素**

假如我们想在原有的数组中再插入一个元素 "S" 呢？

如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。

然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 **腾出** 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 "S"。

我们发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题，我们将在另外的卡片中进行学习。

**删除元素**

删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 **空缺** 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 **填补** 操作。

以删除索引 1 中的元素 "O" 为例，具体过程如图所示。

![](https://pic.leetcode-cn.com/4df7a5a75e5f76b6e7e4540f9403c7c2fee5197a1f30421b4f5d32fdca2cf360-8.gif)

当数组的长度为 n 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 1 + (n - 1) = n 步，其中，1 为删除操作，n - 1 为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为 O(N)，N 为数组的长度。

### 合并区间

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

    输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
    输出: [[1,6],[8,10],[15,18]]
    解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

    输入: intervals = [[1,4],[4,5]]
    输出: [[1,5]]
    解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。

提示：

+ intervals[i][0] <= intervals[i][1]

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {

    }
};
```

**思路**:

先按首位置进行排序;

接下来,如何判断两个区间是否重叠呢?比如 a = [1,4],b = [2,3]

当 a[1] >= b[0] 说明两个区间有重叠.

但是如何把这个区间找出来呢?

左边位置一定是确定，就是 a[0]，而右边位置是 max(a[1], b[1])

所以,我们就能找出整个区间为:[1,4]

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if not intervals: return []
        intervals.sort()
        res = [intervals[0]]
        for x, y in intervals[1:]:
            if res[-1][1] < x:
                res.append([x, y])
            else:
                res[-1][1] = max(y, res[-1][1])
        return res
```

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>> &intervals) {
        vector<vector<int>> res;
        int size = intervals.size();
        if (0 == size) return res;
        sort(intervals.begin(), intervals.end());
        res.push_back(intervals[0]);
        int i(0), j(1);
        while (j < size) {
            if (res[i][1] < intervals[j][0]) {
                res.push_back(intervals[j]);
                ++i;
            } else {
                res[i][1] = max(res[i][1], intervals[j][1]);
            }
            ++j;
        }
        return res;
    }
};
```

## 二维数组简介

前面的章节中，我们已经了解了 一维数组。然而，有时候，我们可能需要用到 多维数组，它更适合像表或矩阵这样更复杂的结构。

本章节中，我们将重点围绕二维数组来解释：

1. 二维数组在内存中是如何存放的？
2. 如何运用二维数组来解决问题？

### 二维数组简介

二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。

![](https://pic.leetcode-cn.com/e64116dc9c9c8f9f8ad2a5c251c0e76a677ba874a3bab0e22ce164384237a55c-1.png)

所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。

**示例**

类似一维数组，对于一个二维数组 A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 **连续** 的空间，并记录第一行数组的索引位置，即 A[0][0] 的内存地址，它的索引与内存地址的关系如下图所示。

![](https://pic.leetcode-cn.com/bf1bd2a80e026f8ce335724e54a457301f5909cfd8ae5a25f8d2692c7cdae720-2.png)

注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 1。

实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。

### 旋转矩阵

给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

示例 1:

    给定 matrix = 
    [
      [1,2,3],
      [4,5,6],
      [7,8,9]
    ],

    原地旋转输入矩阵，使其变为:
    [
      [7,4,1],
      [8,5,2],
      [9,6,3]
    ]

示例 2:

    给定 matrix =
    [
      [ 5, 1, 9,11],
      [ 2, 4, 8,10],
      [13, 3, 6, 7],
      [15,14,12,16]
    ], 

    原地旋转输入矩阵，使其变为:
    [
      [15,13, 2, 5],
      [14, 3, 4, 1],
      [12, 6, 8, 9],
      [16, 7,10,11]
    ]

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {

    }
};
```

思路上总体是对的, 以示例2为例, 我想的需要旋转的数是第一行的5,1,9 和第二行的4, 那么计算会很麻烦. 实际上是把矩阵分为四块, 需要旋转的数是[[5,1],[2,4]]这一块, 这样规律就明显了.

```c++
class Solution {
public:
    void rotate(vector<vector<int>> &matrix) {
        int n = matrix.size();
        if (0 == n) return;
        int row = (n >> 1) - 1;  // 左上角区域的最大行下标
        int column = (n - 1) >> 1;  // 左上角区域的最大列下标，行列下标从 0 开始
        for (int i = row; i >= 0; --i) {
            for (int j = column; j >= 0; --j) {
                swap(matrix[i][j], matrix[j][n - 1 - i]);
                swap(matrix[i][j], matrix[n - 1 - i][n - 1 - j]);
                swap(matrix[i][j], matrix[n - 1 - j][i]);
            }
        }
    }
};
```

### 零矩阵
编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

示例 1：

    输入：
    [
      [1,1,1],
      [1,0,1],
      [1,1,1]
    ]
    输出：
    [
      [1,0,1],
      [0,0,0],
      [1,0,1]
    ]

示例 2：

    输入：
    [
      [0,1,2,0],
      [3,4,5,2],
      [1,3,1,5]
    ]
    输出：
    [
      [0,0,0,0],
      [0,4,5,0],
      [0,3,1,0]
    ]

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {

    }
};
```

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>> &matrix) {
        set<int> r;
        set<int> c;
        int m = matrix.size();
        if (0 == m) return;
        int n = matrix[0].size();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (0 == matrix[i][j]) {
                    r.insert(i);
                    c.insert(j);
                }
            }
        }
        for (int i : r) {
            for (int j = 0; j < n; ++j) {
                matrix[i][j] = 0;
            }
        }
        for (int j : c) {
            for (int i = 0; i < m; ++i) {
                matrix[i][j] = 0;
            }
        }
    }
};
```

### 对角线遍历

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:

    输入:
    [
     [ 1, 2, 3 ],
     [ 4, 5, 6 ],
     [ 7, 8, 9 ]
    ]

    输出:  [1,2,4,7,5,3,6,8,9]

解释:
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png)

说明:

1. 给定矩阵中的元素总数不会超过 100000 。

```c++
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {

    }
};
```

```c++
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>> &matrix) {
        vector<int> res;
        int m = matrix.size();
        if (0 == m) return res;
        int n = matrix[0].size();
        if (0 == n) return res;
        bool flag = true;
        for (int sum = 0; sum < m + n - 1; ++sum) {
            if (flag) {
                int x = (sum < m) ? sum : m - 1;
                int y = sum - x;
                while (x >= 0 && y < n) {
                    res.push_back(matrix[x][y]);
                    --x;
                    ++y;
                }
            } else {
                int y = (sum < n) ? sum : n - 1;
                int x = sum - y;
                while (y >= 0 && x < m) {
                    res.push_back(matrix[x][y]);
                    ++x;
                    --y;
                }
            }
            flag = !flag;
        }
        return res;
    }
};
```

## 字符串简介

正如我们在概述中提到的那样，字符串是一个由字符构成的数组。

本章节中，我们将深入研究字符串。完成本章后，你将：

+ 熟悉字符串中的 基本操作，尤其是在数组中没有的独特操作；
+ 理解不同 比较 函数之间的区别；
+ 理解字符串 是否可变 以及导致连接过程中出现的问题；
+ 能够解决与字符串相关的基本问题，如排序、子串、字符串匹配等。

### 字符串简介

> 维基百科：字符串是由零个或多个字符组成的有限序列。一般记为 s = a1a2...an。它是编程语言中表示文本的数据类型。

**为何单独讨论字符串类型**

我们知道，字符串与数组有很多相似之处，比如使用 `名称[下标]` 来得到一个字符。那么我们为什么要单独讨论字符串呢？原因主要有：

1. 字符串的基本操作对象通常是*字符串整体或者其子串*

例如有这样一个字符串序列：`I like leetcode` 现在你想把这句话反向输出，可能会变成这样：

    edocteel ekil I

这是我们想要的结果吗？你可能会回答不是，因为它没有任何意义。我们通常希望单词仍然维持原来的顺序，这样反向输出之后就是：

    Leetcode like I

这样的结果对于我们来讲是不是更满意呢？维持单词本身的顺序使得我们方便进行更多操作，这里的每个单词就叫做字符串的「子串」，通常，我们的操作对象更多情况下是这些子串。

2. 字符串操作比其他数据类型更复杂（*例如比较、连接操作*）

对于不同的编程语言，字符串的某些操作会有所不同。下面我们将从字符串的「比较」和「连接」操作两个方面份别进行讲解。

**比较函数**

字符串有它自己的比较函数（我们将在下面的代码中向你展示比较函数的用法）。

然而，存在这样一个问题：

> 我们可以用 “==” 来比较两个字符串吗？

这取决于下面这个问题的答案：

> 我们使用的语言是否支持运算符重载？

+ 如果答案是 yes （例如 C++、Python）。我们可以使用 == 来比较两个字符串；
+ 如果答案是 no （例如 Java），我们可能无法使用 == 来比较两个字符串。当我们使用 == 时，它实际上会比较这两个对象是否是同一个对象。

你可以运行下面的例子来比较结果：

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1 = "Hello World";
    cout << "s1 is \"Hello World\"" << endl;
    string s2 = s1;
    cout << "s2 is initialized by s1" << endl;
    string s3(s1);
    cout << "s3 is initialized by s1" << endl;
    // compare by '=='
    cout << "Compared by '==':" << endl;
    cout << "s1 and \"Hello World\": " << (s1 == "Hello World") << endl;
    cout << "s1 and s2: " << (s1 == s2) << endl;
    cout << "s1 and s3: " << (s1 == s3) << endl;
    // compare by 'compare'
    cout << "Compared by 'compare':" << endl;
    cout << "s1 and \"Hello World\": " << !s1.compare("Hello World") << endl;
    cout << "s1 and s2: " << !s1.compare(s2) << endl;
    cout << "s1 and s3: " << !s1.compare(s3) << endl;
}
```

**连接操作**

对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。不可变意味着一旦字符串被初始化，你就无法改变它的内容。

+ 在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。
+ 在其他一些语言（如 Java、Python）中，字符串是不可变的。

你可以通过测试修改操作来确定你喜欢的语言中的字符串是否可变。

在 **字符串不可变** 的语言中，进行字符串的连接操作则会带来一些问题。

显然，不可变字符串无法被修改。哪怕你只是想修改其中的一个字符，也必须创建一个新的字符串。我们以 Java 为例，来看一个在 for 循环中重复进行字符串连接的例子：

```c++
#include <iostream>

int main() {
    string s = "";
    int n = 10000;
    for (int i = 0; i < n; i++) {
        s += "hello";
    }
}
```

```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        String s = "";
        int n = 10000;
        for (int i = 0; i < n; i++) {
            s += "hello";
        }
    }
}
```

我们发现在 C++ 中，进行字符串连接并没有明显的性能影响。

然而，对于 Java来说，由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串。

因此，总时间复杂度将是：

5 + 5 × 2 + 5 × 3 + … + 5 × n = 5 × (1 + 2 + 3 + … + n) = 5 × n × (n + 1) / 2
即 O(N^2)。

针对 Java 中出现的此问题，我们提供了以下解决方案：

+ 如果你确实希望你的字符串是可变的，则可以使用 toCharArray 将其转换为字符数组。
+ 如果你经常必须连接字符串，最好使用一些其他的数据结构，如 StringBuilder 。

### 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

    输入: ["flower","flow","flight"]
    输出: "fl"

示例 2:

    输入: ["dog","racecar","car"]
    输出: ""
    解释: 输入不存在公共前缀。

说明:

所有输入只包含小写字母 a-z 。

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        
    }
};
```

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string> &strs) {
        int size = strs.size();
        if (0 == size) return "";
        int max_len = strs[0].size();
        int m = strs[0].size();
        for (int idx = 1; idx < size; ++idx) {
            int n = strs[idx].size();
            int i(0);
            while (i < max_len && i < n) {
                if (strs[0][i] == strs[idx][i]) {
                    ++i;
                } else {
                    break;
                }
            }
            if (0 == i) return "";
            max_len = min(max_len, i);
        }
        return strs[0].substr(0, max_len);
    }
};
```

### 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：

    输入: "the sky is blue"
    输出: "blue is sky the"

示例 2：

    输入: "  hello world!  "
    输出: "world! hello"
    解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：

    输入: "a good   example"
    输出: "example good a"
    解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

说明：

+ 无空格字符构成一个单词。
+ 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
+ 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

进阶：

请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。

```c++
class Solution {
public:
    string reverseWords(string s) {

    }
};
```

思路:
1. 先整体反转
2. 确定子串的起始位置和结束位置。向前移动，局部反转。
3. 删除末尾多余的空格。

```c++
class Solution {
public:
    string reverseWords(string s) {
        // 反转整个字符串
        reverse(s.begin(), s.end());

        int n = s.size();
        int idx = 0;
        for (int start = 0; start < n; ++start) {
            // 找到下一个字符串的起点
            if (s[start] != ' ') {
                // 填一个空白字符然后将idx移动到下一个单词的开头位置
                if (idx != 0) s[idx++] = ' ';

                // 循环遍历至单词的末尾
                int end = start;
                while (end < n && s[end] != ' ') s[idx++] = s[end++];

                // 反转整个单词
                reverse(s.begin() + idx - (end - start), s.begin() + idx);

                // 更新start，去找下一个单词
                start = end;
            }
        }
        s.erase(s.begin() + idx, s.end());
        return s;
    }
};
```

复杂度分析

+ 时间复杂度：O(N)，其中 N 为输入字符串的长度。

+ 空间复杂度：Java 和 Python 的方法需要 O(N) 的空间来存储字符串，而 C++ 方法只需要 O(1) 的额外空间来存放若干变量。

容易想到的方法是使用stack:

```c++
class Solution {
public:
    string reverseWords(string s) {
        stack<string> my_stack;
        string word;
        int size = s.size();
        for (int i = 0; i < size; ++i) {
            char c = s[i];
            if (word.size() && ' ' == c) {
                my_stack.push(move(word));
                word = "";
            } else if (' ' != c) {
                word += c;
            }
        }
        // 如果word为空字符串, my_stack也会存入空字符串, 导致错误
        if (word.size()) {
            my_stack.push(move(word));
        }

        string ans;
        while (!my_stack.empty()) {
            ans += my_stack.top();
            my_stack.pop();
            if (!my_stack.empty()) ans += ' ';
        }
        return ans;
    }
};
```

复杂度分析

+ 时间复杂度：O(N)，其中 N 为输入字符串的长度。

+ 空间复杂度：O(N)，双端队列存储单词需要 O(N) 的空间。

### 字符串匹配算法：KMP

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m + n)。

这段话你可能并不理解。没关系，我们来看一个例子。

**情景 1**

假如你是一名生物学家，现在，你的面前有两段 DNA 序列 S 和 T，你需要判断 T 是否可以匹配成为 S 的子串。

    S    A A A A A A A G
    T    A A A A G

你可能会凭肉眼立即得出结论：是匹配的。可是计算机没有眼睛，只能对每个字符进行逐一比较。

对于计算机来讲，首先它会从左边第一个位置开始进行逐一比较：

![](https://pic.leetcode-cn.com/9ba3e12042e13d412f00166eca79c6aad1ada7ccf1e0fd2134793833f4d06624-1.gif)

这样，当匹配到 T 的最后一个字符时，发现不匹配，于是从 S 的第二个字符开始重新进行比较：

![](https://pic.leetcode-cn.com/71bda4bc896e8482ef218023a63ba1c6d1a5f8ab8477f8ea122ac5517a1ea880-2.gif)

仍然不匹配，再次将 T 与 S 的第三个字符开始匹配......不断重复以上步骤，直到从 S 的第四个字符开始时，最终得出结论：S 与 T 是匹配的。

![](https://pic.leetcode-cn.com/6ed2dcacd3f9de2106eee74f71c78d25ef97e49deb0f3c926d034f4e96ad5b75-3.gif)

你发现这个方法的弊端了吗？**我们在进行每一轮匹配时，总是会重复对 A 进行比较。**也就是说，对于 S 中的每个字符，我们都需要从 T 第一个位置重新开始比较，并且 S 前面的 A 越多，浪费的时间也就越多。假设 S 的长度为 m，T 的长度为 n，理论上讲，最坏情况下迭代 m - n + 1 轮，每轮最多进行 n 次比对，一共比较了 (m−n+1)×n 次，当 m >> n 时，渐进时间复杂度为 O(mn)。

而 KMP 算法的好处在于，它可以将时间复杂度降低到 O(m + n)，字符序列越长，该算法的优势越明显。它是怎么实现的呢？

**情景 2**

再来举一个例子，现在有如下字符串 S 和 P，判断 P 是否为 S 的子串。

    S    A C T G P A C T G K A C T G P A C Y
    P    A C T G P A C Y

我们仍然按照原来的方式进行比较，比较到 P 的末尾时，我们发现了不匹配的字符。

![](https://pic.leetcode-cn.com/c3dde6e8b72414a720ca76849b4aee32a5ab4833a58388637cae2ad657d4130d-4.gif)

注意，按照原来的思路，我们下一步应将字符串 P 的开头，与字符串 S 的第二位 C 重新进行比较。而 KMP 算法告诉我们，我们只需将**字符串 P 需要比较的位置重置到图中 j 的位置，S 保持 i 的位置不变**，接下来即可从 i，j 位置继续进行比较。

![](https://pic.leetcode-cn.com/98463d52c63ba4ca59d2099f00fe59b42a8669a7bc38349817899001d442c550-5.png)

为什么？我们发现字符串 P 有子串 ACT 和 ACY，当 T 和 Y 不匹配时，我们就确定了 S 中的蓝色 AC 并不匹配 P 右侧的 AC，但是可能匹配左侧的 AC，所以我们从位置 i 和 j 继续比较。

换句话说，Y 对应下标 2，表示下一步要重新开始的地方。

既然如此，如果每次不匹配的时候，我们都能立刻知道 P 中不匹配的元素，下一步应该从哪个下标重新开始，这样不就能大大简化匹配过程了吗？这就是 KMP 的核心思想。

KMP 算法中，使用一个数组 next 来保存 P 中元素不匹配时，下一步应该重新开始的下标。由于计算机不能像我们人类一样，通过视觉来得出结论，因此这里有一种适合计算机的构造 next 数组的方法。

**小插曲：构造 next 数组**

构造方法为：**P[i] 对应的下标，为 P[0...i - 1] 的最长公共前缀后缀的长度，令 P[0] = -1**。 具体解释如下：

例如对于字符串 abcba：

+ 前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
+ 后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
+ 最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。

所以，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 P[i] 的下标，就得到了 next 数组。

![](https://pic.leetcode-cn.com/8cd158c08b74130068b580d6d8830ecb700af1e84897ac07a6c533b9c6c0c6a6-8.png)
 
**回到情景 2**

我们将思绪切换回来，上次我们还停留在位置 i 和 j，现在继续进行比较。从如下图所示，由于我们已经构造了 next 数组，当继续移动到图中的 r 和 c 位置时，发现不匹配，根据 next 数组，我们可以立即将位置 c 回到下标 0 的位置：

![](https://pic.leetcode-cn.com/bce64b7c2d5632cf519725dc61818d60357464f16b7a6472bb7becc2db0e8438-7.png)

之后的情形就很简单了：

+ K 与 A 不匹配，查看 next 数组，A 对应 next 中的元素为 -1，表示不动，r 加 1；
+ 位置 r 字符与位置 c 字符匹配，继续比较下一位；
+ 后面元素均匹配，最终找到匹配元素。

以上就是 KMP 算法的思想，现在回过头来看文章开头的第一句话，你是否有更加深刻的理解了呢？

**结尾**

最后，我们给出相关代码。

KMP 主算法参考代码：

```c++
int match(const char* P, const char* S) {  // KMP 算法
    int* next = buildNext(P);              // 构造 next 表
    int m = (int)strlen(S), i = 0;         // 文本串指针
    int n = (int)strlen(P), j = 0;         //模式串指针
    while (j < n && i < m) {               // 自左向右逐个比对字符
        if (0 > j || S[i] == P[j])  // 若匹配，或 P 已移除最左侧
        {
            i++;
            j++;
        }  // 则转到下一字符
        else
            j = next[j];  // 模式串右移（注意：文本串不用回退）
    }
    delete[] next;  // 释放 next 表
    return i - j;
}
```

构造 next 表参考代码：

```c++
int* buildNext(const char* P) {  // 构造模式串 P 的 next 表
    size_t m = strlen(P);
    size_t j = 0;         // “主”串指针
    int* N = new int[m];  // next 表
    N[0] = -1;
    int t = -1;  // 模式串指针
    while (j < m - 1) {
        if (0 > t || P[j] == P[t]) {  // 匹配
            j++;
            t++;
            N[j] = t;  // 此句可改进为 N[j] = (P[j] != P[t] ? t : N[t]);
        } else         // 失配
            t = N[t];
    }
    return N;
}
```
