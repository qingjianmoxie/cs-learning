# 算法简介

## 什么是好的算法？

+ 空间复杂度S(n) —— 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。

+ 时间复杂度T(n) —— 根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的算法可能导致我们在有生之年都等不到运行结果。

## 一些常见的大O运行时间

+ O(log n)，也叫对数时间，这样的算法包括二分查找。
+ O(n)，也叫线性时间，这样的算法包括简单查找。
+ O(n * log n)，这样的算法包括快速排序——一种速度较快的排序算法。
+ O(n^2)，这样的算法包括选择排序——一种速度较慢的排序算法。
+ O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

## 旅行商问题

有一位旅行商, 他需要前往5个城市, 同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。
对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。因此，在涉及5个城市时，解决这个问题需要执行120次操作。涉及6个城市时，需要执行720次操作（有720种不同的排列方式）。涉及7个城市时，需要执行5040次操作！
推而广之，涉及n个城市时，需要执行n!（n的阶乘）次操作才能计算出结果。因此运行时间为O(n!)，即阶乘时间。除非涉及的城市数很少，否则需要执行非常多的操作。如果涉及的城市数超过100，根本就不能在合理的时间内计算出结果——等你计算出结果，太阳都没了。
这种算法很糟糕！旅行商应使用别的算法，可他别无选择。这是计算机科学领域待解的问题之一。对于这个问题，目前还没有找到更快的算法，有些很聪明的人认为这个问题根本就没有更巧妙的算法。面对这个问题，我们能做的只是去找出近似答案，更详细的信息请参阅第10章。