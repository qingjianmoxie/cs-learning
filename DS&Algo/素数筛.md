# 素数筛

**素数筛法**，是一种快速“筛”出2~n之间所有素数的方法。

我们如何计算出2~n中素数的个数呢? 小白程序员想到的是暴力解法.

```c++
// 返回区间 [2, n] 中有几个素数 
int countPrimes(int n) {
    int count = 0;
    for (int i = 2; i <= n; i++) {
        if (isPrim(i)) count++;
    }
    return count;
}

// 判断整数 n 是否是素数
bool isPrime(int n) {
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            // 有其他整除因子
            return false;
        }
    }
    return true;
}
```

这样写的话时间复杂度为 O(n*sqrt(n)) = O(n^1.5)。

## 埃氏筛

朴素的筛法叫**埃氏筛**（the Sieve of Eratosthenes，**埃拉托色尼筛**），它的过程是这样的：

我们把2~n的数按顺序写出来：

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

从前往后看，找到第一个未被划掉的数，2，这说明它是质数。然后把2的倍数（不包括2）划掉：

2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ 9 ~~10~~ 11 ~~12~~ 13 ~~14~~ 15 ~~16~~

下一个未被划掉的数是3，它是质数，把3的倍数划掉：

2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ ~~9~~ ~~10~~ 11 ~~12~~ 13 ~~14~~ ~~15~~ ~~16~~

接下来应该是5，但是5已经超过 sqrt(16) 了，所以遍历结束，剩下未被划掉的都是素数：

**2** **3** ~~4~~ **5** ~~6~~ **7** ~~8~~ ~~9~~ ~~10~~ **11** ~~12~~ **13** ~~14~~ ~~15~~ ~~16~~

如何？是不是比一个一个判断快多了？这个过程写成代码就是：

```c++
int countPrimes(int n) {
    vector<bool> isPrim(n + 1, true);

    for (int i = 2; i <= n; i++) { 
        if (isPrim[i]) { 
            // i 的倍数不可能是素数了
            for (int j = 2 * i; j <= n; j += i) { 
                isPrim[j] = false;
            }
        }
    }
    
    int count = 0;
    for (int i = 2; i <= n; i++) {
        if (isPrim[i]) count++;
    }

    return count;
}
```

如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。

首先，回想刚才判断一个数是否是素数的 `isPrime` 函数，其中的 for 循环只需要遍历 `[2,sqrt(n)]` 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 `sqrt(n)`：

```c++
for (int i = 2; i * i <= n; i++) 
    if (isPrim[i]) 
        ...
```

除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：

```c++
for (int j = 2 * i; j <= n; j += i) {
    isPrim[j] = false;
}
```

这样可以把 `i` 的整数倍都标记为 `false`，但是仍然存在计算冗余。

我们可以稍微优化一下，让 `j` 从 `i` 的平方开始遍历，而不是从 `2 * i` 开始, 显然这是正确的：

```c++
for (int j = i * i; j <= n; j += i) 
    isPrim[j] = false;
```

这样，素数计数的算法就高效实现了，这就是埃氏筛：

```c++
int countPrimes(int n) {
    vector<bool> isPrim(n + 1, true);

    for (int i = 2; i * i <= n; i++) { 
        if (isPrim[i]) { 
            // i 的倍数不可能是素数了
            for (int j = i * i; j <= n; j += i) { 
                isPrim[j] = false;
            }
        }
    }
    
    int count = 0;
    for (int i = 2; i <= n; i++) {
        if (isPrim[i]) count++;
    }

    return count;
}
```

该算法的时间复杂度比较难算，显然时间跟这两个嵌套的 for 循环有关，其操作数应该是：

  n/2 + n/3 + n/5 + n/7 + ...
= n × (1/2 + 1/3 + 1/5 + 1/7...)

括号中是素数的倒数。其最终结果是 O(N * loglogN)，有兴趣的读者可以查一下该算法的时间复杂度证明。

## 欧拉筛

但是我们可能会发现，在筛的过程中我们还是会重复筛到同一个数，例如12同时被2和3筛到，30同时被2、3和5筛到。所以我们引入**欧拉筛**，也叫**线性筛**，可以在 O(n) 时间内完成对2~n的筛选。它的核心思想是：**让每一个合数被其最小质因数筛到**。

我们这次除了把2~n列出来，还维护一个**质数表**：

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
    primes:()

还是从头到尾遍历，第一个数是2，未被划掉，把它放进质数表：

**2** 3 4 5 6 7 8 9 10 11 12 13 14 15 16
    primes:(2,)

然后我们用2去乘质数表里的每个数，划掉它们：

**2** 3 ~~4~~ 5 6 7 8 9 10 11 12 13 14 15 16
    primes:(2,)

下一个是3，加入质数表，划掉6、9：

**2** **3** ~~4~~ 5 ~~6~~ 7 8 ~~9~~ 10 11 12 13 14 15 16
        primes:(2,3,)

下一个是4（注意这里划掉的数也要遍历，只是不加入质数表），先划掉8，但我们不划掉12，因为12 (12 = 2x6 = 3x4) 应该由它的最小质因数2筛掉，而不是3。

**2** **3** ~~4~~ 5 ~~6~~ 7 ~~8~~ ~~9~~ 10 11 12 13 14 15 16
        primes:(2,3,)

实际上，对于 x，我们遍历到质数表中的 p，且发现 p|x 时，就应当停止遍历质数表。因为：设 x=pr(r≥p)（p 本身是 x 的最小质因数），那么对于任意 p' > p，有 p'x=pp'r=p(p'r)，说明 p'x 的最小质因数不是 p'，我们不应该在此划掉它。

这么说有点抽象，具体地说，如这里的2能整除4，则 4 = 2x2，那么对于任何大于2的质数 p，都有 4p = 2 x 2p，其中2是一个比 p 更小的质数，所以 4p 应该被2筛掉而不是被 p 筛掉。

下一个是5，加入质数表，划掉10，15：

**2** **3** ~~4~~ 5 ~~6~~ 7 ~~8~~ ~~9~~ ~~10~~ 11 12 13 14 ~~15~~ 16
        primes:(2,3,5,)

下一个是6，划掉12，6被2整除，跳过。

**2** **3** ~~4~~ 5 ~~6~~ 7 ~~8~~ ~~9~~ ~~10~~ 11 ~~12~~ 13 14 ~~15~~ 16
        primes:(2,3,5,)
……

按这样的步骤进行下去，可以筛掉所有的合数，并得到一张质数表。

**2** **3** ~~4~~ **5** ~~6~~ **7** ~~8~~ ~~9~~ ~~10~~ **11** ~~12~~ **13** ~~14~~ ~~15~~ ~~16~~
        primes:(2,3,5,7,11,13)

我们可以保证每个合数都被筛过，设任意合数 x=pr(r≥p)，其中 p 是 x 的最小质因数，又设 r=p'r'(r'≥p')， p' 是 r 的最小质因数。在处理 r 时，要遍历质数表，直到遇到 p' 时才结束，所以任意小于等于 p' 的质数与 r 的乘积，都会在此时被筛掉。

而由于一定有 p ≤ p' （因为 x 的最小质因数是 p，而不是 p'），所以在处理到 r 时， rp 一定会被筛到。

代码如下：

```c++
bool isnp[MAXN];
vector<int> primes; // 质数表
void init(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!isnp[i])
            primes.push_back(i);
        for (int p : primes)
        {
            if (p * i > n)
                break;
            isnp[p * i] = 1;
            if (i % p == 0)
                break;
        }
    }
}
```

注意判断越界那里最好使用乘法而不是除法，一般不会溢出，计算机算除法比乘法要慢得多。

欧拉筛除了解决一些卡埃氏筛的毒瘤题（比如[洛谷P3383](https://www.luogu.com.cn/problem/P3383)，线性筛模板）外，在后续一些数论算法中还有更多的应用。
