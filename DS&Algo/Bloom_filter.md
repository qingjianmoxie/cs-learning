# 布隆过滤器(Bloom filter)

> 5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些**32bit**大小的数据该如何解决？如果是**64bit**的呢？

在面试时遇到的问题，问题的解决方案十分典型，但对于**海量数据处理**接触少的同学可能一时也想不到什么好方案。介绍两个算法，对于空间的利用到达了一种极致，那就是Bitmap和[布隆过滤器(Bloom filter)](https://en.wikipedia.org/wiki/Bloom_filter)。

# Bitmap算法

在网上并没有找到Bitmap算法的中文翻译，在《编程珠玑》中有提及。与其说是算法，不如说是一种紧凑的数据存储结构。其实如果并非如此大量的数据，有很多排重方案可以使用，典型的就是**哈希表**。

```c++
#include <iostream>
#include <unordered_map>
#include <vector>

std::vector<int> removeDuplicates(const std::vector<int> &arr) {
    std::vector<int> newArr;
    std::unordered_map<int, bool> map;
    for (int num : arr) {
        if (map.find(num) == map.end()) {
            newArr.push_back(num);
            map.insert(std::make_pair(num, true));
        }
    }
    return newArr;
}

int main() {
    std::vector<int> vec = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
    std::vector<int> res = removeDuplicates(vec);
    for (int num : res) {
        std::cout << num << " ";
    }
    return 0;
}
```

实际上，哈希表实际上为**每一个可能出现的数字**提供了一个**一一映射**的关系，每个元素都相当于有了自己的独享的一份空间，这个映射由散列函数来提供（这里我们先不考虑碰撞）。实际上哈希表甚至还能记录每个元素出现的次数，这样的数据结构完成这个任务有点“大材小用”了。

我们拆解一下我们的需求：

1.  集合中每个元素（示例中是`int`）有一个**独享的空间**
2.  找到一个到这个空间的**映射方法**

这个空间要多大？对于我们的问题来说，1个bit就够了，我们**只想知道某个元素出现过没有**。如果为每个所有可能的值分配1个bit，32bit的`int`所有可能取值需要内存空间为：

2^32 bit = 2^29 Byte = 512 MB

那怎么样完成这个映射呢？其实就是Bitmap所要完成的工作了。如果我们把整型0x01、0x02、…、0x08的空间依次映射到一个Byte上，每个bit就代表这个`int`值是否出现过，初值为0（false）。

若扩展到整个`int`取值域，申请一个数组即可，示例代码如下：

```c++
#include <iostream>
#include <unordered_map>
#include <vector>

const int _1MB = 1024 * 1024;
const int _512MB = 512 * _1MB;
char *flags = new char[_512MB];

void setFlag(int num) {
    //使用每个数的低三位作为数组内的映射
    //例如: 255 = (11111111)
    //低三位(也就是num & (0x07))为(111) = 7, 则数组的第7位为1, 表示255已存在
    flags[num >> 3] |= 0x01 << (num & (0x07));
}

bool getFlag(int num) {
    return (flags[num >> 3] >> (num & (0x07)) & 0x01) == 0x01;
}

int main() {
    // 待判重数据
    std::vector<int> vec = {255, 1024, 0, 65536, 255};
    std::vector<int> res;
    for (int num : vec) {
        if (!getFlag(num)) {
            //未出现的元素
            res.push_back(num);
            //设置标志位
            setFlag(num);
            std::cout << "set " << num << std::endl;
        } else {
            std::cout << num << " already exist" << std::endl;
        }
    }
    return 0;
}
```

其实，就是按`int`从小到大的顺序依次摆放到数组中，仅涉及到一些除以2的整次幂和对2的整次幂取余的位操作小技巧。

很显然，对于小数据量、数据取值很稀疏，上面的方法并没有什么优势，但对于**海量的、取值分布很均匀**的集合进行去重，Bitmap极大地压缩了所需要的内存空间。于此同时，还额外地完成了对原始数组的排序工作。缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。

# 布隆过滤器（Bloom filter）

然而Bitmap不是万能的，如果数据量大到一定程度，如开头写的64bit类型的数据，还能不能用Bitmap？我们来算一算：

2^64 bit = 2^61 Byte = 2048 PB = 2 EB

EB（Exabyte，艾字节）这个计算机科学中统计数据量的单位有多大，有兴趣的小伙伴可以查阅下资料。这个量级的Bitmap，已经不是人类硬件所能承担的了。我相信谁也不会想用集群去计算这么一个问题吧？(勘误：原谅我当年的孤陋寡闻，工业还有另一个著名实现是Map Reduce，正是用集群方案来解决“海量数据处理”的问题。)所以Bitmap的好处在于**空间复杂度不随原始集合内元素的个数增加而增加**，而它的坏处也源于这一点——**空间复杂度随集合内最大元素增大而线性增大**。

## 另一个算法题目

我们再看一道题目:

> 如果一个黑名单网站包含100亿个黑名单网页，每个网页最多占64B，设计一个系统，判断当前的URL是否在这个黑名单当中，要求额外空间不超过30GB，允许误差率为万分之一。

这个问题的解题思路也是使用布隆过滤器.

## 基础介绍

> 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。
> 布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

实际上，布隆过滤器广泛应用于网页黑名单系统、垃圾邮件过滤系统、爬虫网址判重系统等，有人会想，我直接将网页URL存入数据库进行查找不就好了，或者建立一个哈希表进行查找不就OK了。

当数据量小的时候，这么思考是对的，但如果整个网页黑名单系统包含100亿个网页URL，在数据库查找是很费时的，并且如果每个URL空间为64B，那么需要内存为640GB，一般的服务器很难达到这个需求。

那么，在这种内存不够且检索速度慢的情况下，不妨考虑下布隆过滤器，但业务上要可以忍受判断失误率。

如果说Bitmap对于每一个可能的整型值，通过直接寻址的方式进行映射，相当于使用了一个哈希函数，那布隆过滤器就是引入了k(k>1)个**相互独立**的哈希函数，保证在给定的空间、**误判率**下，完成元素判重的过程。下图中是k=3时的布隆过滤器。
![图1 布隆过滤器（来源：wiki）](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjI3MTUxMzUzNTA1?x-oss-process=image/format,png)

x,y,z经由哈希函数映射将各自在Bitmap中的3个位置置为1，当w出现时，仅当3个标志位都为1时，才表示w在集合中。图中所示的情况，布隆过滤器将判定w不在集合中。

## 布隆过滤器为什么会有误判

当插入的元素越来越多时，当一个不在布隆过滤器中的元素，经过同样规则的哈希计算之后，得到的值在位数组中查询，有可能这些位置因为其他的元素先被置1了。

所以布隆过滤器存在误判的情况，但是如果布隆过滤器判断某个元素不在布隆过滤器中，那么这个值就一定不在。

## 使用场景
+ 网页爬虫对URL的去重，避免爬去相同的URL地址。
+ 垃圾邮件过滤，从数十亿个垃圾邮件列表中判断某邮箱是否是杀垃圾邮箱。
+ 解决数据库缓存击穿，黑客攻击服务器时，会构建大量不存在于缓存中的key向服务器发起请求，在数据量足够大的时候，频繁的数据库查询会导致挂机。
+ 秒杀系统，查看用户是否重复购买。
