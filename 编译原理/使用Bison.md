# 使用Bison

本章我们将介绍bison, 不过我们依然用flex来生成我们的词法分析器. flex可以识别正则表达式, 而bison可以识别语法. flex把输入流分解为若干个片段(记号), 而bison则分析这些记号并基于逻辑进行组合. 本章我们将完成第一章的桌面计算器, 首先加入简单的算术功能, 接着是一些内置功能和用户变量, 最后是用户的自定义函数.

## 基于抽象语法树的计算器

例3-1: 创建基于抽象语法树的计算器  
[头文件3-1.h](./3-1.h)  
抽象语法树由多个节点组成, 每个节点都有一个节点类型. 不同的节点可以有不同的域, 但目前我们只有两种类型, 一种是指向最多两个子节点的指针, 另外一种包含一个数值.

[bison语法分析器3-1](3-1.y)  
这个分析器的第一部分使用`%union`来声明语法分析器中符号值的类型. 在bison语法分析器中, 每个语法符号都可以有一个相应的值. 默认情况下所有的符号值都是整数, 但是真正有用的程序通常需要更多有价值的符号值.  
而%union, 正如它的名字所暗示的那样, 可以用来为符号值创建一个C语言的union(联合)类型. 在这个例子中, 联合类型有两个成员: 一个是a, 指向一个抽象语法树的指针; 一个是d, 它是一个双精度浮点数.  
一旦联合类型被定义, 我们需要告诉bison每种语法符号使用的值类型, 这通过放置在尖括号中的联合类型的相应成员名字来确定. 记号NUMBER代表输入中的数字, 它通过`<d>`来保存具体的数值. 新的声明`%type`把值`<a>`赋给exp、factor和term, 当我们创建抽象语法树时会用到它们.  
如果你不使用语法符号的值, 则并不需要为它们声明类型. 当声明中存在`%union`时, 如果试图使用一个没有被赋予类型的符号值, bison将报错. 记住如果没有显式的语义动作代码, 规则将使用默认语义动作`$$ = $1`; 而当左边符号和右边符号具有不同的类型时, bison也会报错.

[词法分析器3-1](3-1.l)  
例3-1展示的词法分析器比第一章的版本简单些. 我们使用常用的手法来描述单字符操作符, 通过同一条规则处理它们, 然后把`yytext[0]`, 也就是它们自身, 作为记号返回. 我们使用第二章中的模式版本处理浮点数, 并且把内部的数值类型改成了双精度浮点数. 由于yylval现在是联合类型, 双精度浮点数的值将不得不赋给yylval.d(flex无法像bison那样自动地管理记号值).

[C例程3-1.c](./3-1.c)
eval和treefree两个遍历树的例程, 都采用了名为深度优先(depth-first)的算法, 首先递归访问每个节点的所有子树, 然后再访问节点本身.
最后是yyerror和main, 这个版本的yyerror使用了可变长参数, 它可以接受printf格式的参数列表, 这在生成错误消息时十分方便.
(疑问: treefree的时候,如果是两颗子树, 为什么只释放a->r?)

## 编译基于抽象语法树的计算器
我们使用make来编译它.
```makefile
3-1: 3-1.l 3-1.y 3-1.h
    bison -d 3-1.y
    flex 3-1.l
    gcc -std=c99 -o $@ 3-1.tab.c lex.yy.c 3-1.c
```
注意, bison自动基于.y文件来命名生成的C文件, 但是flex总是把它的C文件命名为lex.yy.c, 除非你另行指定.

## 移进/归约冲突和操作符优先级

表达式分析器使用了三种不同的语法符号, exp, factor和term, 来设置操作符的优先级和结合性. 虽然这个语法分析器目前还是比较清晰的, 但是随着更多具有不同优先级的操作符被添加到语法中, 整个语法会变得难以阅读和维护.

在语法中有两种方法来指定优先级和结合性: 隐式定义和显示定义. 以前我们都是隐式指定它们的, 对不同的优先级使用了不同的非终结符. 但是bison允许你显式地指定优先级. bison提供了一个很聪明的方法, 他可以在语法规则之外单独描述优先级, 这使得语法和分析器都变得短小而且易于维护.

[bison语法分析器3-2](./3-2.y)
每个声明都定义了一种优先级, `%left`, `%right`和`%noassoc`的出现顺序决定了由低到高的优先级顺序. 
这些定义告诉bison `+` 和 `-` 是左结合的, 而且具有最低的优先级;  
`*` 和 `/` 也是左结合的, 但具有更高的优先级;  
而 `|` 和 UMINUS(代表单目负号操作符的伪记号)没有结合性, 并且具有最高的优先级(在这里我们没有右结合操作符, 如果有的话应该使用%right).  
使用优先级的语法分析器比前一个使用额外规则来做隐式优先级定义的语法分析器来得更小更快, 因为它具有更少需要归约的规则.
