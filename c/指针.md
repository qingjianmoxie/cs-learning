# 指针

## 初识指针

计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如 int 占用 4 个字节，char 占用 1 个字节。为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号、身份证号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。

下图是 4G 内存中每个字节的编号（以十六进制表示）：
![4G 内存中每个字节的编号](https://upload-images.jianshu.io/upload_images/5436814-afa0e449a2e1c7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们将内存中字节的编号称为地址（Address）或指针（Pointer）。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。

## 一切都是地址

C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。

数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。

CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址。如果程序不小心出错，或者开发者有意为之，在 CPU 要写入数据时给它一个代码区域的地址，就会发生内存访问错误。这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。

CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。

假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算`c = a + b;`将会被转换成类似下面的形式：

`0X3000 = (0X1000) + (0X2000);`

`( )`表示取值操作，整个表达式的意思是，取出地址 0X1000 和 0X2000 上的值，将它们相加，把相加的结果赋值给地址为 0X3000 的内存

变量名和函数名为我们提供了方便，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，不用直接面对二进制地址，那场景简直让人崩溃。

需要注意的是，虽然变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符，但在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址。

## 指针的定义

数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为**指针变量**。

在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。

现在假设有一个 char 类型的变量 c，它存储了字符 'K'（ASCII码为十进制数 75），并占用了地址为 0X11A 的内存。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。

![image](https://upload-images.jianshu.io/upload_images/5436814-89840f8459a2ddba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

指针变量也可以连续定义，例如：

`int *a, *b, *c;  //a、b、c 的类型都是 int*`

注意每个变量前面都要带`*`。如果写成下面的形式，那么只有 a 是指针变量，b、c 都是类型为 int 的普通变量：

`int *a, b, c;`

## 通过指针变量取得数据

指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：

`*pointer;`

这里的`*`称为指针运算符，用来取得某个地址上的数据，请看下面的例子：

```c++
#include <stdio.h>
int main(){
    int a = 15;
    int *p = &a;
    printf("%d, %d\n", a, *p);  //两种方式都可以输出a的值
    return 0;
}
```
运行结果：
15, 15

上节我们说过，CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过 *p 和 a 获取到的数据一样，但它们的运行过程稍有不同：a 只需要一次运算就能够取得数据，而 *p 要经过两次运算，多了一层“间接”。

假设变量 a、p 的地址分别为 0X1000、0XF0A0，它们的指向关系如下图所示：

![image](https://upload-images.jianshu.io/upload_images/5436814-367fb2ff5483b377.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

程序被编译和链接后，a、p 被替换成相应的地址。使用 *p 的话，要先通过地址 0XF0A0 取得变量 p 本身的值，这个值是变量 a 的地址，然后再通过这个值取得变量 a 的数据，前后共有两次运算；而使用 a 的话，可以通过地址 0X1000 直接取得它的数据，只需要一步运算。

也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。

`*`在不同的场景下有不同的作用：`*`可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；使用指针变量时在前面加`*`表示获取指针指向的数据，或者说表示的是指针指向的数据本身。

也就是说，定义指针变量时的`*`和使用指针变量时的`*`意义完全不同。以下面的语句为例：

```c++
int *p = &a;
*p = 100;
```

第1行代码中`*`用来指明 p 是一个指针变量，第2行代码中`*`用来获取指针指向的数据。

需要注意的是，给指针变量本身赋值时不能加`*`。修改上面的语句：
```c++
int *p;
p = &a;
*p = 100;
```
第2行代码中的 p 前面就不能加`*`。

## 指针的应用场景

1. 需要传⼊较⼤的数据时⽤作参数。
1. 传⼊数组后对数组做操作。
1. 传入的参数实际上是需要保存带回结果的变量，比如swap函数。
1. 函数的返回值用来判断函数内的运算成功与否，而运算结果通过指针返回。
1. 动态申请的内存。

## 字符串指针

C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中，这里演示如下：
```c++
#include <stdio.h>
#include <string.h>
int main(){
    char str[] = "hello";
    int len = strlen(str), i;
    //直接输出字符串
    printf("%s\n", str);
    //每次输出一个字符
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```
运行结果：
hello
hello

字符数组归根结底还是一个数组，上节讲到的关于指针和数组的规则同样也适用于字符数组。更改上面的代码，使用指针的方式来输出字符串：
```c++
#include <stdio.h>
#include <string.h>
int main(){
    char str[] = "hello";
    char *pstr = str;
    int len = strlen(str), i;
    //使用*(pstr+i)
    for(i=0; i<len; i++){
        printf("%c", *(pstr+i));
    }
    printf("\n");
    //使用pstr[i]
    for(i=0; i<len; i++){
        printf("%c", pstr[i]);
    }
    printf("\n");
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");
    return 0;
}
```
运行结果：
hello
hello
hello

除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：
char *str = "hello";
或者：
char *str;
str = "hello";
字符串中的所有字符在内存中是连续排列的，str 指向的是字符串的第0个字符；我们通常将第0个字符的地址称为字符串的首地址。字符串中每个字符的类型都是char，所以 str 的类型也必须是`char *`。

下面的例子演示了如何输出这种字符串：
```c++
#include <stdio.h>
#include <string.h>
int main(){
    char *str = "hello";
    int len = strlen(str), i;
   
    //直接输出字符串
    printf("%s\n", str);
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");
    //使用str[i]
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```
运行结果：
hello
hello
hello

这一切看起来和字符数组是多么地相似，它们都可以使用`%s`输出整个字符串，都可以使用`*`或`[ ]`获取单个字符，这两种表示字符串的方式是不是就没有区别了呢？

有！它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。

内存权限的不同导致的一个明显结果就是，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的。

我们将第二种形式的字符串称为字符串常量，意思很明显，常量只能读取不能写入。请看下面的演示：
```c++
#include <stdio.h>
int main(){
    char *str = "Hello World!";
    str = "I love C!";  //正确
    str[3] = 'P';  //错误
    return 0;
}
```
这段代码能够正常编译和链接，但在运行时会出现段错误（Segment Fault）或者写入位置错误。

第4行代码是正确的，可以更改指针变量本身的指向；第5行代码是错误的，不能修改字符串中的字符。

## 指针使用常见错误

1. 使用未初始化的指针
```c++
int *p;
···
*p = 10;
```
上述程序将值10写到未知的内存位置，如果p指向系统内存空间，这样很可能把系统本来地址里的内容给覆盖了，会导致程序或者系统的崩溃。

2. 不断修改内存指针变量
```c++
char *p = (char *)malloc(100);
strcpy(p, "abcdefg");
p += 1;
*p = 'a';
free(p);
```
此程序主要错误在于释放内存的时候释放位置不对，指针指向改变，释放了不该释放的位置，程序出错。这种时候一般会定义两个指向同一个开辟的内存空间的指针变量，一个用于操作，一个用于释放。