# 指针与数组

1. 把数组作为参数传递的时候，会退化为指针。
数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅是一个指针；很遗憾，在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
所以，函数参数表中的数组实际上是指针！
典型情况如下：
```c++
void func(int A[])
{
   //sizeof(A)得到的是4bytes
}

int main()
{
   int a[10]; //sizeof(a) 得到的结果是40bytes
   funct(a);
}
```

数组变量是特殊的指针:

+  数组变量本⾝表达地址，所以  
    `int a[10]; int*p=a; // ⽆需⽤&取地址`  
    但是数组的单元表达的是变量，需要⽤&取地址  
    `a == &a[0]`  
+ []运算符可以对数组做，也可以对指针做：
    p[0] <==> a[0]  
+ *运算符可以对指针做，也可以对数组做：
    `*a = 25;`  
+ 数组变量是const的指针，所以不能被赋值
    `int a[] <==> int * const a`  

2. 数组是开辟一块连续的内存空间,数组本身的标示符代表整个数组,可以用sizeof取得真实的大小；指针则是只分配一个指针大小的内存,并可把它的值指向某个有效的内存空间。

## 指针与const

+ `const在*前面：意思是所指的是const，不能通过这个指针去修改那个变量`
+ `const在*后面：意思是指针是const，不能再指向其他的变量`

## 数组指针

数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以`int arr[] = { 99, 15, 100, 888, 252 };`为例，该数组在内存中的分布如下图所示：

![image](https://upload-images.jianshu.io/upload_images/5436814-1f9c625578916b88.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第0个元素。在C语言中，我们将第0个元素的地址称为数组的首地址。以上面的数组为例，下图是arr的指向：

![image](https://upload-images.jianshu.io/upload_images/5436814-424f0d7926b2447d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 数组名的本意是表示整个数组，也就是表示多份数据的集合，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“认为”一词，表示数组名和数组首地址并不总是等价。初学者可以暂时忽略这个细节，把数组名当做指向第0个元素的指针使用即可。

下面的例子演示了如何以指针的方式遍历数组元素：
```c++
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    int i;
    for(i=0; i<len; i++){
        printf("%d  ", *(arr+i) );  //*(arr+i)等价于arr[i]
    }
    printf("\n");
    return 0;
}
```
运行结果：
99  15  100  888  252

第5行代码用来求数组的长度，sizeof(arr) 会获得整个数组所占用的字节数，sizeof(int) 会获得一个数组元素所占用的字节数，它们相除的结果就是数组包含的元素个数，也即数组长度。

第8行代码中我们使用了`*(arr+i)`这个表达式，arr 是数组名，指向数组的第0个元素，表示数组首地址，arr+i指向数组的第i个元素，`*(arr+i)`表示取第i个元素的数据，它等价于`arr[i]`。

我们也可以定义一个指向数组的指针，例如：
```c++
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以`int *p = arr;`也可以写作`int *p = &arr[0];`。也就是说，`arr`、`p`、`&arr[0]`这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。

> 再强调一遍，“arr 本身就是一个指针”这种表述并不准确，严格来说应该是“arr 被转换成了一个指针”。这里请大家先忽略这个细节。

如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。

数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是`int *`。

反过来想，p 并不知道它指向的是一个数组，p 只知道它指向的是一个整数，究竟如何使用 p 取决于程序员的编码。

更改上面的代码，使用数组指针来遍历数组元素：
```c++
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){
        printf("%d  ", *(p+i) );
    }
    printf("\n");
    return 0;
}
```
数组在内存中只是数组元素的简单排列，没有开始和结束标志，在求数组的长度时不能使用sizeof(p)/sizeof(int)，因为 p 只是一个指向 int 类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 sizeof(p) 求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数。

也就是说，根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。不像字符串，数组本身也没有特定的结束标志，如果不知道数组的长度，那么就无法遍历整个数组。

引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针。

1. 使用下标
也就是采用`arr[i]`的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用`p[i]`来访问数组元素，它等价于`arr[i]`。

2. 使用指针
也就是使用`*(p+i)`的形式访问数组元素。另外数组名本身也是指针，也可以使用`*(arr+i)`来访问数组元素，它等价于`*(p+i)`。

不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。

## 指针数组

如果一个数组中的所有元素都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：

`dataType *arrayName[length];`

`[ ]`的优先级高于`*`，该定义形式应该理解为：

`dataType *(arrayName[length]);`

括号里面说明`arrayName`是一个数组，包含了`length`个元素，括号外面说明每个元素的类型为`dataType *`。

除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的例子：
```c
#include <stdio.h>
int main()
{
    int a = 16, b = 932, c = 100;
    //定义一个指针数组
    int *arr[3] = {&a, &b, &c}; //也可以不指定长度，直接写作 int *arr[]
    //定义一个指向指针数组的指针
    int **parr = arr;
    printf("%d, %d, %d\n", *arr[0], *arr[1], *arr[2]);
    printf("%d, %d, %d\n", **(parr + 0), **(parr + 1), **(parr + 2));
    return 0;
}
```
运行结果：
16, 932, 100
16, 932, 100

arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。

parr 是指向数组 arr 的指针，确切地说是指向 arr 第 0 个元素的指针，它的定义形式应该理解为`int *(*parr)`，括号中的`*`表示 parr 是一个指针，括号外面的`int *`表示 parr 指向的数据的类型。arr 第 0 个元素的类型为 int *，所以在定义 parr 时要加两个 *。

第一个 printf() 语句中，`arr[i]`表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个`*`才能取得它指向的数据，也即`*arr[i]`的形式。

第二个 printf() 语句中，parr+i 表示第 i 个元素的地址，`*(parr+i)`表示获取第 i 个元素的值（该元素是一个指针），`**(parr+i)`表示获取第 i 个元素指向的数据。

指针数组还可以和字符串数组结合使用，请看下面的例子：
```c
#include <stdio.h>
int main()
{
    char *str[3] = {
        "yang",
        "wang",
        "mo"};
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
}
```
运行结果：
yang
wang
mo

需要注意的是，字符数组 str 中存放的是字符串的首地址，不是字符串本身，字符串本身位于其他的内存区域，和字符数组是分开的。

也只有当指针数组中每个元素的类型都是`char *`时，才能像上面那样给指针数组赋值，其他类型不行。

为了便于理解，可以将上面的字符串数组改成下面的形式，它们都是等价的。
```c
#include <stdio.h>
int main()
{
    char *str0 = "yang";
    char *str1 = "wang";
    char *str2 = "mo";
    char *str[3] = {str0, str1, str2};
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
}
```