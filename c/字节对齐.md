# 字节对齐

## 什么是字节对齐

对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在32位cpu下，假设一个整型变量的地址为0x00000004，那它就是自然对齐的。

在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

## 为什么要字节对齐

各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

需要字节对齐的根本原因提高CPU访问数据的效率。  
假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据.  
如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。  

比如sparc系统就对对齐要求非常严格，如果取未对齐的数据会发生错误，举个例：
```c
char ch[8];
char *p = &ch[1];
int i = *(int *)p;
```
运行时会报segment error，而在x86上就不会出现错误，只是效率下降。

## 正确处理字节对齐
　　
对于标准数据类型，它的地址是它的长度的整数倍:

+ char 偏移量必须为sizeof(char) 即1的倍数,可以任意地址开始存储
+ short 偏移量必须为sizeof(short) 即2的倍数,只能从0,2,4...等2的倍数的地址开始存储
+ int 偏移量必须为sizeof(int) 即4的倍数,只能从0,4,8...等4的倍数的地址开始存储
+ float 偏移量必须为sizeof(float) 即4的倍数,只能从0,4,8...等4的倍数的地址开始存储
+ double 偏移量必须为sizeof(double) 即8的倍数,只能从0,8,16...等地址开始存储

而非标准数据类型按下面的原则对齐:
　　
+ 数组: 按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。
+ 联合: 按其包含的长度最大的数据类型对齐。
+ 结构体: 结构体中每个数据类型都要对齐。

比如有如下一个结构体：
```c
typedef struct student
{
    char sex;
    int length;
    char name[10];
} student;
student my_stu;
```

由于在x86下，GCC默认按4字节对齐，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们`sizeof(my_stu)`会得到长度为20，而不是15.

## __attribute__选项

我们可以按照自己设定的对齐大小来编译程序，GNU使用__attribute__选项来设置. ` __attribute__((aligned(n)))`可以让结构成员对齐在n字节自然边界上. **如果结构中有成员的长度大于n, 则按最大成员的长度对齐.**

例如修改字节对齐为1:
```c
typedef struct student
{
    char sex;
    int length;
    char name[10];
} __attribute__((aligned(1))) student;
student my_stu;
```
`sizeof(my_stu)`的结果依然是20。因为设定的字节对齐为1, 而结构体中成员的最大字节数是int 4字节, 1<4, 按照4字节对齐, 和系统默认一致.

修改字节对齐为8:
```c
typedef struct student
{
    char sex;
    int length;
    char name[10];
} __attribute__((aligned(8))) student;
```
`sizeof(my_stu)`的结果为24.

这个设定比较鸡肋, 设定小于成员的长度没作用, 设定大了浪费空间, 效率也没提高.

如果要对结构体按1字节对齐, 可以使用`__attribute__((packed))`:

```c
typedef struct student
{
    char sex;
    int length;
    char name[10];
} __attribute__((packed)) student;
```
`__attribute__((packed))`对变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐.

## pragma pack

在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：
+ 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。
+ 使用伪指令#pragma pack ()，取消自定义字节对齐方式。


## 什么时候需要设置对齐

在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样.
