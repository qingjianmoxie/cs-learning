# min和max宏

假如现在你去一家公司面试，要求：**定义一个宏，求两个数中的最大数**。

此处不要再往下看，停顿5分钟，写出你的答案，然后跟后面的答案对比。

-----------停顿5分钟------------------------------------

## **合格**

对于学过C语言的同学，写出这个宏基本上不是什么难事，使用条件运算符就能完成：

```
#define  MAX(x,y)  x > y ? x : y
```

这是最基本的C语言语法，如果连这个也写不出来，估计场面会比较尴尬。面试官为了缓解尴尬，一般会对你说：小伙子，你很棒，回去等消息吧，有消息，我们会通知你！这时候，你应该明白：不用再等了，赶紧把这篇文章看完，接着面下家。这个宏能写出来，也不要觉得你很牛X，因为这只能说明你有了C语言的基础，但还有很大的进步空间。比如，我们写一个程序，验证一下我们定义的宏是否正确：

```
#define MAX(x,y) x > y ? x : y
int main(void)
{
    printf("max=%d",MAX(1,2));
    printf("max=%d",MAX(2,1));
    printf("max=%d",MAX(2,2));
    printf("max=%d",MAX(1!=1,1!=2));
    return 0;
}
```

测试程序么，我们肯定要把各种可能出现的情况都测一遍。这不，测试第4行语句，当宏的参数是一个表达式，发现实际运行结果为max=0,跟我们预期结果max=1不一样。这是因为，宏展开后，就变成了这个样子：

```
printf("max=%d",1!=1>1!=2?1!=1:1!=2);
```

因为比较运算符 > 的优先级为6，大于 !=(优先级为7)，所以展开的表达式，运算顺序发生了改变，结果就跟我们的预期不一样了。为了避免这种展开错误，我们可以给宏的参数加一个小括号()来防止展开后，表达式的运算顺序发生变化。这样的宏才能算一个合格的宏：

```
#define MAX(x,y) (x) > (y) ? (x) : (y)
```

## **中等**

上面的宏，只能算合格，但还是存在漏洞。比如，我们使用下面的代码测试：

```
#define MAX(x,y) (x) > (y) ? (x) : (y)
int main(void)
{
    printf("max=%d",3 + MAX(1,2));
    return 0;
}
```

在程序中，我们打印表达式 3 + MAX(1, 2) 的值，预期结果应该是5，但实际运行结果却是1。我们展开后，发现同样有问题：

```
3 + (1) > (2) ? (1) : (2);
```

因为运算符 + 的优先级大于比较运算符 >，所以这个表达式就变为4>2?1:2，最后结果为1也就见怪不怪了。此时我们应该继续修改这个宏：

```
#define MAX(x,y) ((x) > (y) ? (x) : (y))
```

使用小括号将宏定义包起来，这样就避免了当一个表达式同时含有宏定义和其它高优先级运算符时，破坏整个表达式的运算顺序。如果你能写到这一步，说明你比前面那个面试合格的同学强，前面那个同学已经回去等消息了，我们接着面试下一轮。

## **良好**

上面的宏，虽然解决了运算符优先级带来的问题，但是仍存在一定的漏洞。比如，我们使用下面的测试程序来测试我们定义的宏：

```
#define MAX(x,y) ((x) > (y) ? (x) : (y))
int main(void)
{
    int i = 2;
    int j = 6;
    printf("max=%d",MAX(i++,j++));
    return 0;
}
```

在程序中，我们定义两个变量 i 和 j，然后比较两个变量的大小，并作自增运算。实际运行结果发现max = 7，而不是预期结果max = 6。这是因为变量 i 和 j 在宏展开后，做了两次自增运算，导致打印出 i 的值为7。

遇到这种情况，那该怎么办呢？ 这时候，语句表达式就该上场了。我们可以使用语句表达式来定义这个宏，在语句表达式中定义两个临时变量，分别来暂储 i 和 j 的值，然后进行比较，这样就避免了两次自增、自减问题。

```c
#define MAX(x,y)({     \
    int _x = x;        \
    int _y = y;        \
    _x > _y ? _x : _y; \
})
int main(void)
{
    int i = 2;
    int j = 6;
    printf("max=%d",MAX(i++,j++));
    return 0;
}
```

这里用到了GCC的一个扩展特性，形如({ ... })这样的代码块会被视为一条语句，其计算结果是{ ... }中最后一条语句的计算结果。故上述宏定义展开后的结果就是第5行返回的结果。注意，这个扩展特性不是所有编译器都有的，如果用VS编译上述代码，是无法通过编译的。

在语句表达式中，我们定义了2个局部变量`_x`、`_y`来存储宏参数 x 和 y 的值，然后使用`_x`和`_y`来比较大小，这样就避免了 i 和 j 带来的2次自增运算问题。

你能坚持到了这一关，并写出这样自带BGM的宏，面试官心里可能已经有了给你offer的意愿了。但此时此刻，千万不要骄傲！为了彻底打消面试官的心理顾虑，我们需要对这个宏继续优化。

## **优秀**

在上面这个宏中，我们定义的两个临时变量数据类型是int型，只能比较两个整型的数据。那对于其它类型的数据，就需要重新再定义一个宏了，这样太麻烦了！我们可以基于上面的宏继续修改，让它可以支持任意类型的数据比较大小：

```c
#define max(x, y) ({				\
	typeof(x) _max1 = (x);			\
	typeof(y) _max2 = (y);			\
	(void)(&_max1 == &_max2);		\
	_max1 > _max2 ? _max1 : _max2; })
```

typeof是GNU C新增的一个关键字，用来获取数据类型，我们不用传参进去，让typeof直接获取！

在这个宏定义中，使用了typeof关键字用来获取宏的两个参数类型。干货在`(void) (&_max1 == &_max2);`这句话，简直是天才般的设计！一是用来给用户提示一个警告，对于不同类型的指针比较，编译器会给一个警告，提示两种数据类型不同；二是，当两个值比较，比较的结果没有用到，有些编译器可能会给出一个warning，加个(void)后，就可以消除这个警告！

以上的宏解决了自增自减运算符 ++/-- 带来的一系列问题。但也不是十全十美，还是有漏洞：在宏内部的语句表达中，我们定义了2个临时变量`_max1`和`_max2`解决了 ++/-- 带来的问题，但是也引入了一个新漏洞, 比如当我们使用下面的代码时：

```c
max(_max1, _max2)
```

当宏展开后，参数就与宏内部定义的临时变量同名了，这就影响宏最后的结果。因此，为了防止用户传入的参数跟宏内部的临时变量产生同名冲突，我们可以将宏内部的临时变量尽量定义得复杂一些，降低同名冲突的概率。

然而，靠起特殊的名字这种方法不是那么的优雅，故实际新版的Linux Kernel中使用了编译器产生的唯一名称来解决这一问题：

```c
/* Indirect macros required for expanded argument pasting, eg. __LINE__. */
#define ___PASTE(a,b) a##b
#define __PASTE(a,b) ___PASTE(a,b)

#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)

/*
 * min()/max()/clamp() macros that also do
 * strict type-checking.. See the
 * "unnecessary" pointer comparison.
 */
#define __max(t1, t2, max1, max2, x, y) ({              \
	t1 max1 = (x);                                  \
	t2 max2 = (y);                                  \
	(void) (&max1 == &max2);                        \
	max1 > max2 ? max1 : max2; })

#define max(x, y)                                       \
	__max(typeof(x), typeof(y),                     \
	      __UNIQUE_ID(max1_), __UNIQUE_ID(max2_),   \
	      x, y)
```
在新版的宏中，内部的临时变量不再由程序员自己定义，而是让编译器生成一个独一无二的变量，这样就避免了同名冲突的风险。宏__UNIQUE_ID的作用就是生成了一个独一无二的变量，确保了临时变量的唯一性。